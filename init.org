#+TITLE: Emacs Configuration
#+AUTHOR: Terje Larsen
#+PROPERTY: header-args:emacs-lisp :tangle yes :results silent

* Introduction
  terlar's Emacs Configuration. It is not very well documented right now, but hopefully I
  will have time to write down some more details later.

  The rough details:
  - theme :: [[https://github.com/11111000000/tao-theme-emacs][tao-theme]] (yang) with [[file:lisp/local-theme.el][some local modifications]]
    - fonts :: [[https://github.com/be5invis/Iosevka][Iosevka Slab]], Noto Sans, Noto Serif
    - semantic highlighting :: [[https://github.com/ankurdave/color-identifiers-mode][color-identifiers-mode]], [[https://github.com/Fanael/rainbow-identifiers][rainbow-identifiers]] (fallback, with wider support)
  - menu completion :: [[https://github.com/abo-abo/swiper][ivy]]
  - +buffer completion :: [[https://github.com/company-mode/company-mode][company-mode]], [[https://github.com/tumashu/company-childframe][company-childframe]]+
  - +modal editing (vi) :: [[https://github.com/emacs-evil/evil][evil]]+
  - package configuration :: [[https://github.com/jwiegley/use-package][use-package]]
  - key definitions :: [[https://github.com/noctuid/general.el][general]]
  - code navigation :: [[https://github.com/jacktasia/dumb-jump][dumb-jump]], [[https://github.com/jojojames/smart-jump][smart-jump]], [[https://github.com/iqbalansari/emacs-source-peek][source-peek]]
  - syntax checker :: flymake
  - persistent undo :: via built-in =desktop-save-mode=

** Screenshots
*** org-mode
    #+CAPTION: org-mode
    [[file:media/org-mode.png]]

*** markdown-mode
    #+CAPTION: markdown-mode
    [[file:media/markdown-mode.png]]

*** emacs-lisp-mode
    #+CAPTION: emacs-lisp-mode
    [[file:media/emacs-lisp-mode.png]]

* The beginning
  Every good file starts with a nice header and enable lexical scoping as per the
  recommendations of the [[https://github.com/bbatsov/emacs-lisp-style-guide#source-code-layout--organization][The Emacs Lisp Style Guide]].
  #+BEGIN_SRC emacs-lisp
  ;;; init.el --- Emacs Initialization -*- lexical-binding: t; -*-
  #+END_SRC

** Variables
   Provide an easy way to toggle debug mode which will set certain variables to produce
   more informative output. It can be set either by providing the environment variable
   =DEBUG= or start Emacs with =--debug-init=.
   #+BEGIN_SRC emacs-lisp
   (eval-and-compile
     (defvar +debug-mode
       (or (getenv "DEBUG") init-file-debug)
       "Debug mode, enable through DEBUG=1 or use --debug-init.")
     (setq debug-on-error (and (not noninteractive) +debug-mode)))
   #+END_SRC

   Provide a location where Emacs can store data and cache.
   #+BEGIN_SRC emacs-lisp
   (eval-and-compile
     (defvar +data-dir
       (if (getenv "XDG_DATA_HOME")
           (concat (getenv "XDG_DATA_HOME") "/emacs/")
         (expand-file-name "~/.local/share/emacs/"))
       "Directory for data.")

     (defvar +cache-dir
       (if (getenv "XDG_CACHE_HOME")
           (concat (getenv "XDG_CACHE_HOME") "/emacs/")
         (expand-file-name "~/.cache/emacs/"))
       "Directory for cache."))
   #+END_SRC

** Quiet startup
   #+BEGIN_SRC emacs-lisp
   (setq inhibit-default-init t
         inhibit-startup-screen t
         initial-major-mode 'fundamental-mode
         initial-scratch-message nil)
   #+END_SRC

** UX
   Disable bell (both visual and audible)
   #+BEGIN_SRC emacs-lisp
   (setq ring-bell-function #'ignore
         visible-bell nil)
   #+END_SRC

   Use =y= / =n= instead of =yes= / =no=
   #+BEGIN_SRC emacs-lisp
   (setq confirm-kill-emacs #'y-or-n-p)
   (fset #'yes-or-no-p #'y-or-n-p)
   #+END_SRC

** Custom file
   Put custom defs in a temporary file so it doesn't grow over time.
   #+BEGIN_SRC emacs-lisp
   (setq custom-file
         (expand-file-name "custom.el" temporary-file-directory))
   #+END_SRC

** Load path
   #+BEGIN_SRC emacs-lisp
   (eval-and-compile
     (setq load-path
           (append (delete-dups load-path)
                   (list (expand-file-name "lisp" user-emacs-directory)))))
   #+END_SRC

** Shell
   Set shell to bash as fish is not compatible with all packages using the shell.
   #+BEGIN_SRC emacs-lisp
   (setq shell-file-name "bash")
   #+END_SRC

** Package management
   Don't use defualt =package.el=:
   #+BEGIN_SRC emacs-lisp
   (setq package-enable-at-startup nil)
   #+END_SRC

*** use-package
    #+BEGIN_SRC emacs-lisp
    (eval-when-compile
      (require 'use-package))
    (setq use-package-always-defer t)

    (if +debug-mode
        (setq use-package-verbose t
              use-package-expand-minimally nil
              use-package-compute-statistics t)
      (setq use-package-verbose nil
            use-package-expand-minimally t))
    #+END_SRC

** Packages
*** no-littering
    Help keeping =~/.emacs.d= clean.
    #+BEGIN_SRC emacs-lisp
    (use-package no-littering
      :demand t
      :preface
      (defvar no-littering-etc-directory +data-dir)
      (defvar no-littering-var-directory +cache-dir))
    #+END_SRC

*** exec-path-from-shell
    #+BEGIN_SRC emacs-lisp
    (use-package exec-path-from-shell
      :demand t
      :custom
      (exec-path-from-shell-check-startup-files nil)
      :config
      (exec-path-from-shell-initialize))
    #+END_SRC

*** server
    #+BEGIN_SRC emacs-lisp
    (use-package server
      :commands
      (server-running-p)
      :preface
      (defun +server-ensure-running (frame)
        "Ensure server is running when launching FRAME."
        (with-selected-frame frame
          (unless (server-running-p)
            (server-start))))
      :init
      (add-hook 'after-make-frame-functions #'+server-ensure-running))
    #+END_SRC

*** savehist
    Persist history.
    #+BEGIN_SRC emacs-lisp
    (use-package savehist
      :custom
      (savehist-additional-variables
       '(kill-ring
         search-ring
         regexp-search-ring))
      (savehist-autosave-interval 60)
      (savehist-save-minibuffer-history t)
      :init
      (savehist-mode 1))
    #+END_SRC

** Libraries
*** cl-lib
    #+BEGIN_SRC emacs-lisp
    (require 'cl-lib)
    #+END_SRC

*** async
    #+BEGIN_SRC emacs-lisp
    (use-package async
      :demand t)
    #+END_SRC

*** flymake-quickdef
    #+BEGIN_SRC emacs-lisp
    (use-package flymake-quickdef)
    #+END_SRC

*** posframe
    #+BEGIN_SRC emacs-lisp
    (use-package posframe
      :custom
      (posframe-mouse-banish nil))
    #+END_SRC

** Tangling
   Support auto-tangling via =auto-tangle-mode=.
   #+BEGIN_SRC emacs-lisp
   (require 'auto-tangle)
   #+END_SRC

* Base
** Performance
   Disable bidirectional text for tiny performance boost
   #+BEGIN_SRC emacs-lisp
   (setq-default bidi-display-reordering nil)
   #+END_SRC

   Update UI less frequently
   #+BEGIN_SRC emacs-lisp
   (setq idle-update-delay 2
         jit-lock-defer-time 0
         jit-lock-stealth-time 0.2
         jit-lock-stealth-verbose nil)
   #+END_SRC

** Localization
   #+BEGIN_SRC emacs-lisp
   (setq-default calendar-week-start-day 1)
   #+END_SRC

** Terminal
*** Pager
    Make less work inside Emacs shells. But disable it as the default pager.
    #+BEGIN_SRC emacs-lisp
    (setenv "LESS" "--dumb --prompt=s")
    (setenv "PAGER" "")
    #+END_SRC

** Packages
*** all-the-icons
    Support functions for displaying icons. I am trying to use icons where possible.
    #+BEGIN_SRC emacs-lisp
    (use-package all-the-icons
      :demand t)
    #+END_SRC

*** auto-minor-mode
    Enable minor modes by buffer name and contents. It provides the =use-package= keyword
    =:minor= and =:magic-minor= where you can specify these rules.
    #+BEGIN_SRC emacs-lisp
    (use-package auto-minor-mode :disabled)
    #+END_SRC

*** defrepeater
    Support defining repeating commands by repeating the last key.
    #+BEGIN_SRC emacs-lisp
    (use-package defrepeater)
    #+END_SRC

*** diminish
    Hide mode-line modes, more room for important stuff.
    #+BEGIN_SRC emacs-lisp
    (use-package diminish)
    #+END_SRC

*** general
    More convenient key definitions. I provides the =use-package= keyword =:general=.
    #+BEGIN_SRC emacs-lisp
    (use-package general
      :demand t)
    #+END_SRC

*** hide-lines
    #+BEGIN_SRC emacs-lisp
    (use-package hide-lines)
    #+END_SRC

*** minions
    #+BEGIN_SRC emacs-lisp
    (use-package minions
      :general
      ([C-S-mouse-1] 'minions-minor-modes-menu))
    #+END_SRC

*** quick-peek
    Library to display inline popups; used by =source-peek=.
     #+BEGIN_SRC emacs-lisp
    (use-package quick-peek)
     #+END_SRC

*** vlf
    Large file support. This can view/edit/search and compare large files.
    #+BEGIN_SRC emacs-lisp
    (use-package vlf)
    #+END_SRC

*** which-key
    Display available keybindings in a popup.
    #+BEGIN_SRC emacs-lisp
    (use-package which-key
      :defer 1
      :diminish which-key-mode
      :custom
      (which-key-sort-order #'which-key-key-order-alpha)
      (which-key-sort-uppercase-first nil)
      (which-key-add-column-padding 1)
      (which-key-min-display-lines 5)
      (which-key-idle-delay 1)
      :config
      (dolist (item '((("<\\([[:alnum:]-]+\\)>" . nil) . ("\\1" . nil))
                      (("\\`\\?\\?\\'" . nil) . ("λ" . nil))
                      (("<up>" . nil) . ("↑" . nil))
                      (("<right>" . nil) . ("→" . nil))
                      (("<down>" . nil) . ("↓" . nil))
                      (("<left>" . nil) . ("←" . nil))
                      (("SPC" . nil) . ("␣" . nil))
                      (("TAB" . nil) . ("↹" . nil))
                      (("RET" . nil) . ("⏎" . nil))
                      (("DEL" . nil) . ("⌫" . nil))
                      (("deletechar" . nil) . ("⌦" . nil))))
        (cl-pushnew item which-key-replacement-alist :test #'equal))

      (which-key-setup-side-window-bottom)

      (which-key-mode 1))
    #+END_SRC

** Functions
   Prevent forms from producing output or other noise.
   #+BEGIN_SRC emacs-lisp
   (defmacro quiet! (&rest forms)
     "Run FORMS without making any noise."
     `(if +debug-mode
          (progn ,@forms)
        (let ((message-log-max nil))
          (with-temp-message (or (current-message) "") ,@forms))))

   (defun quiet-function-advice (orig-fn &rest args)
     "Advice used to make a function quiet.
   Call ORIG-FN with ARGS and suppress the output.

   Example:
     (advice-add #'orig-fun :around #'quiet-function-advice)"
     (quiet! (apply orig-fn args)))
   #+END_SRC

   Run forms when graphical frame is created.
   #+BEGIN_SRC emacs-lisp
   (defmacro eval-after-make-graphic-frame (hook-id &rest forms)
     "Run HOOK-ID hook with FORMS after making a frame on a graphic display.
      Add a hook to `after-make-frame-functions' with form wrapped in a
      `display-graphic-p' condition."
     (let ((hook-name (intern
                       (concat
                        "+eval-after-make-graphic-frame--"
                        hook-id
                        "-hook"))))
       `(progn
          (defun ,hook-name (frame)
            (with-selected-frame frame
              (when (display-graphic-p frame)
                ,@forms)))
          (add-hook 'after-make-frame-functions #',hook-name))))
   #+END_SRC

*** Display
    #+BEGIN_SRC emacs-lisp
    (defun display-ctrl-M-as-newline ()
      "Display `^M' as newline."
      (interactive)
      (setq buffer-display-table (make-display-table))
      (aset buffer-display-table ?\^M [?\n]))
    #+END_SRC

*** Editing
    #+BEGIN_SRC emacs-lisp
    (defun turn-on-truncate-lines ()
      "Enable `truncate-lines' for the current buffer."
      (setq truncate-lines t))

    (defun turn-off-truncate-lines ()
      "Disable `truncate-lines' for the current buffer."
      (setq truncate-lines nil))
    #+END_SRC

*** Process
    #+BEGIN_SRC emacs-lisp
    (defun send-buffer-to-ssh ()
      "Send the whole buffer to the *ssh* process."
      (interactive)
      (process-send-region "*ssh*" (point-min) (point-max)))

    (defun send-to-ssh ()
      "Send selected region or current line to the *ssh* process."
      (interactive)
      (let ((procbuf "*ssh*"))
        (if (use-region-p)
            (process-send-region procbuf (region-beginning) (region-end))
          (process-send-string procbuf (thing-at-point 'line t)))))
    #+END_SRC

*** Utils
    #+BEGIN_SRC emacs-lisp
    (defun work-log-file ()
      "Open today's work log file."
      (interactive)
      (let ((daily-name (format-time-string "%Y-%m-%d")))
        (find-file (expand-file-name (concat "~/org/worklog-" daily-name ".org")))))

    (defun sprint-file ()
      "Open current sprint log file."
      (interactive)
      (let ((sprint-name (format-time-string "%Y-W%W")))
        (find-file (expand-file-name (concat "~/org/sprint-" sprint-name ".org")))))
    #+END_SRC

*** Window
    #+BEGIN_SRC emacs-lisp
    (defun toggle-dedicated-window ()
      "Toggle selected window as dedicated window."
      (interactive)
      (set-window-dedicated-p (selected-window)
                              (not (window-dedicated-p (selected-window)))))
    #+END_SRC

* Keybindings
  I am trying to reduce the amount of keybindings, therefore I present a table of default
  keybindings in case I would forget them.

  | Keybinding | Alternative |
  |------------+-------------|
  | =M-=         | =C-[=         |
  | =TAB=        | =C-i=         |
  | =RET=        | =C-j=        |

  | Keybinding      | Function                        | Description                                                                      |
  |-----------------+---------------------------------+----------------------------------------------------------------------------------|
  | =C-o=             | =open-line=                       | Open line below                                                                  |
  | =M-SPC=           | =just-one-space=                  | Ensures just one space                                                           |
  | =M-\=             | =delete-horizontal-space=         | Delete all space                                                                 |
  | =M-^=             | =delete-indentation=              | Join current line with previous line                                             |
  | =M-z=             | =zap-to-char=                     | Delete until character                                                           |
  | =C-S-backspace=   | =kill-whole-line=                 | Kill entire lines, can be used to move several lines at once                     |
  | =M-/=             | =dabbrev-expand=                  | Abbreviation completion                                                          |
  | =M-tab= / =C-[ C-i= | =completion-at-point= / =pcomplete= | More context aware completion                                                    |
  | =C-w=             | =kill-region=                     | Cut                                                                              |
  | =M-w=             | =kill-ring-save=                  | Copy                                                                             |
  | =C-y=             | =yank=                            | Paste                                                                            |
  | =M-y=             | =yank-next=                       | Paste (next item)                                                                |
  | =C-x SPC=         | =rectangle-mark-mode=             | Rectangular selection                                                            |
  | =C-x r t=         | =string-rectangle=                | Insert string in beginning of rectangular selection (=C-t= in =rectangle-mark-mode=) |
  | =C-M-f=           | =forward-sexp=                    | Move forward inside a balanced expression                                        |
  | =C-M-b=           | =backward-sexp=                   | Move backward inside a balanced expression                                       |
  | =C-M-n=           | =forward-list=                    | Move forward across one balanced group of parenthesis                            |
  | =C-M-p=           | =backward-list=                   | Move backward across one balanced group of parenthesis                           |
  | =M-m=             | =back-to-indentation=             | Move to the first non-whitespace character                                       |
  | =M-e=             | =forward-sentence=                | End of sentence                                                                  |
  | =M-a=             | =backward-sentence=               | Start of sentence                                                                |
  | =C-M-d=           | =down-list=                       | Move forward down one level of parenthesis                                       |
  | =C-M-u=           | =backward-up-list=                | Move backward out of one level of parenthesis                                    |

** Ivy
  | Keybinding | Function           | Description                                              |
  |------------+--------------------+----------------------------------------------------------|
  | =C-M-j=      | =ivy-immediate-done= | Accept input without selecting, (e.g. for new file name) |

** Leader keys
    #+BEGIN_SRC emacs-lisp
    (defvar +leader-key "C-,"
      "The key used for most custom operations.")
    (defvar +local-leader-key "C-."
      "The key used for major mode operations.")
    (defvar +evil-normal-state-leader-key "SPC"
      "The key used for most custom operations in `evil-normal-state'.")
    #+END_SRC

** Prefixes
    #+BEGIN_SRC emacs-lisp
    (defvar +launch-prefix "C-c l"
      "Key prefix for commands related to launching.")

    (defvar +toggle-prefix "C-x t"
      "Key prefix for commands related to toggling.")
    (defvar +window-prefix "C-'"
      "Key prefix used for commands related to window operations.")

    (defvar +nav-prefix "M-g"
      "Key prefix used for commands related to navigation.")
    (defvar +search-prefix "M-s"
      "Key prefix used for commands related to search.")

    (defvar +next-prefix "M-]"
      "Key prefix used for commands doing a next operation.")
    (defvar +prev-prefix "M-["
      "Key prefix used for commands doing a previous operation.")

    #+END_SRC

** Global
    #+BEGIN_SRC emacs-lisp
    (general-define-key
     :keymaps 'global
     ;; Editing
     "C-z" 'zap-up-to-char
     ;; Files
     "C-c o" 'ff-find-other-file
     "C-c O" 'ff-test-find-other-file
     ;; Terminal
     "C-!" 'eshell
     "C-M-!" '(lambda () (interactive) (term "fish"))
     ;; Window
     "C-`" 'window-toggle-side-windows)
    #+END_SRC

** Navigation
   #+BEGIN_SRC emacs-lisp
   (general-define-key
    :keymaps 'global
    :prefix +nav-prefix
    "u" 'browse-url)
   #+END_SRC

** Window
   #+BEGIN_SRC emacs-lisp
   (general-define-key
    :keymaps 'global
    :prefix +window-prefix
    +window-prefix 'window-toggle-side-windows
    "d" 'toggle-dedicated-window
    "m" 'maximize-window)
   #+END_SRC

** Next
   #+BEGIN_SRC emacs-lisp
   (general-define-key
    :prefix +next-prefix
    ""  '(:ignore t :wk "next...")
    "]" `(,(defrepeater #'text-scale-increase)          :wk "Text size")
    "b" `(,(defrepeater #'next-buffer)                  :wk "Buffer")
    "c" `(,(defrepeater #'smerge-next)                  :wk "Conflict")
    "d" `(,(defrepeater #'diff-hl-next-hunk)            :wk "Diff Hunk")
    "e" `(,(defrepeater #'next-error)                   :wk "Error")
    "s" `(,(defrepeater #'flyspell-goto-next-error)     :wk "Spell error")
    "t" `(,(defrepeater #'hl-todo-next)                 :wk "Todo"))
   #+END_SRC

** Previous
   #+BEGIN_SRC emacs-lisp
   (general-define-key
    :prefix +prev-prefix
    ""  '(:ignore t :wk "previous...")
    "[" `(,(defrepeater #'text-scale-decrease)          :wk "Text size")
    "b" `(,(defrepeater #'previous-buffer)              :wk "Buffer")
    "c" `(,(defrepeater #'smerge-prev)                  :wk "Conflict")
    "d" `(,(defrepeater #'diff-hl-previous-hunk)        :wk "Diff Hunk")
    "e" `(,(defrepeater #'previous-error)               :wk "Error")
    "t" `(,(defrepeater #'hl-todo-previous)             :wk "Todo"))
   #+END_SRC

** Toggle
   #+BEGIN_SRC emacs-lisp
   (general-define-key
    :prefix +toggle-prefix
    "c" '(highlight-changes-mode           :wk "Changes")
    "d" '(toggle-debug-on-error            :wk "Debug on error")
    "f" '(hs-minor-mode                    :wk "Code folding")
    "h" '(hl-line-mode                     :wk "Line highlight")
    "l" '(global-display-line-numbers-mode :wk "Line numbers")
    "s" '(subword-mode                     :wk "Sub-word")
    "t" '(toggle-truncate-lines            :wk "Truncate lines")
    "v" '(variable-pitch-mode              :wk "Variable-pitch")
    "w" '(whitespace-mode                  :wk "White-space")
    "x" '(flymake-mode                     :wk "Syntax checker"))
   #+END_SRC

** Launch
   #+BEGIN_SRC emacs-lisp
   (general-define-key
    :prefix +launch-prefix
    "m" 'gnus
    "p" 'list-processes
    "x" 'regexp-builder
    "w" 'eww)
   #+END_SRC

* Help
  #+BEGIN_SRC emacs-lisp
  (general-define-key
   :keymaps 'help-map
   "B" 'find-library
   "u" 'describe-face
   "U" 'list-faces-display
   "'" 'describe-char)
  #+END_SRC

* Appearance
** Typography
*** Size
    #+BEGIN_SRC emacs-lisp
    (eval-and-compile
      (defvar +line-spacing 0.25
        "Spacing between lines.")

      (defvar +default-font-height 120
        "Default font height."))
    #+END_SRC

*** Face
    #+BEGIN_SRC emacs-lisp
    (eval-and-compile
      (defvar +fixed-pitch-font "Iosevka Slab"
        "Font used for fixed-pitch faces.")

      (defvar +variable-pitch-font "Noto Sans"
        "Font used for variable-pitch faces.")

      (defvar +serif-font "Noto Serif"
        "Font used for serif faces.")

      (defvar +unicode-font "Noto Sans Mono"
        "Fallback font used for unicode glyphs.")

      (defvar +emoji-font "Noto Emoji"
        "Font used for symbol/emoji faces."))

    (eval-after-make-graphic-frame
     "setup-emoji-font"
     (set-fontset-font "fontset-default" 'symbol
                       (font-spec :family +emoji-font) nil 'prepend))
    #+END_SRC

*** Line length
    #+BEGIN_SRC emacs-lisp
    (setq-default fill-column 90)
    #+END_SRC

** Theme
*** tao-theme (tao-yang)
    An excellent, light, uncoloured theme.
    #+BEGIN_SRC emacs-lisp
    (use-package tao-theme
      :demand t
      :custom
      (tao-theme-use-sepia t))

    (load-theme 'tao-yang t)
    #+END_SRC

*** Local overrides
    No theme is perfect, also this is a good place to put my own experiments.
    #+BEGIN_SRC emacs-lisp
    (require 'local-theme)
    (load-theme 'local t)
    #+END_SRC

*** Echo area
    Adjust the font face used for the echo area.
    #+BEGIN_SRC emacs-lisp
    (dolist (buffer-name '(" *Echo Area 0*"
                           " *Echo Area 1*"))
      (with-current-buffer (get-buffer-create buffer-name)
        (setq-local face-remapping-alist
                    '((default (:height 0.9) variable-pitch)))))
    #+END_SRC

** Layout
*** Frame
    See [[info:elisp#Frame%20Layout][Frame Layout]] documentation for details and terminology.
    - Add some padding around the whole window (=internal-border-width=) to provide some air.
    - Remove GUI elements.
    - Maximize the window; A maximized window ensures macOS won't waste extra space
      all-though it is technically not maximized.
    - Make the title-bar transparent on macOS.
    #+BEGIN_SRC emacs-lisp
    (setq default-frame-alist
          '((internal-border-width . 16)
            (vertical-scroll-bars . nil)
            (menu-bar-lines . 0)
            (tool-bar-lines . 0)))

    (when (eq system-type 'darwin)
      (setq frame-title-format nil)
      (dolist (filter '((ns-transparent-titlebar . t)
                        (ns-appearance . unbound)))
        (cl-pushnew filter default-frame-alist :test #'equal)))
    #+END_SRC

*** Fringe
    Setup fringes on both sides and display an indicator for buffer boundaries on the
    right side. Display fringes outside margins to have the [[Padding][padding]] on the inside.
    #+BEGIN_SRC emacs-lisp
   (setq-default fringes-outside-margins t
                 left-fringe-width 8
                 right-fringe-width 8
                 indicate-buffer-boundaries 'right)
    #+END_SRC

*** Padding
    Add margins inside windows to make text feel less crowded. Padding around the frame is
    configured via the =internal-border-width= in the [[Frame][Frame]] section.
    #+BEGIN_SRC emacs-lisp
    (setq-default left-margin-width 1
                  right-margin-width 1)
    #+END_SRC

*** Borders
    Add window dividers, mainly to add a border below the mode line.
    #+BEGIN_SRC emacs-lisp
    (setq window-divider-default-places t
          window-divider-default-bottom-width 1
          window-divider-default-right-width 1)

    (eval-after-make-graphic-frame
     "setup-window-divider"
     (window-divider-mode 1))
    #+END_SRC

** Mode line
   I am trying to keep the original mode line as much as possible to ensure compatibility
   with various packages and features, but I have rearranged the position of things and
   also introduced a right side mode line. I have defined a helper function to fill up the
   space needed to make the mode line appear on the right side.

*** Right alignment
    Setup the right aligned mode line and helper functions to display it.
    #+BEGIN_SRC emacs-lisp
    (defvar mode-line-space
      '(:propertize
        " " display
        ((space :width 1)))
      "Space between mode line components.")

    (defvar mode-line-right-format nil
      "The mode line to display on the right side.")

    (defun mode-line-right ()
      "Render the `mode-line-right-format'."
      (let ((formatted-line (format-mode-line mode-line-right-format)))
        (list
         (propertize
          " "
          'display `((space :align-to
                            (- (+ right
                                  right-fringe
                                  right-margin
                                  right-margin-width
                                  left-fringe
                                  left-margin-width)
                               ,(* (string-width formatted-line)
                                   0.8)))))
         formatted-line)))

    (setq-default mode-line-format
                  (append
                   mode-line-format
                   '((:eval (mode-line-right)))))
    #+END_SRC

    Move default components to the right side of the mode line.
    #+BEGIN_SRC emacs-lisp
    (delete 'mode-line-position mode-line-format)
    (delete 'mode-line-mule-info mode-line-format)
    (delete 'mode-line-modes mode-line-format)

    (setq mode-line-right-format
          `(,mode-line-position
            (:eval mode-line-mule-info)
            ,mode-line-space
            ,mode-line-modes))
    #+END_SRC

*** Position
    Add position information including column and line number but skip the percentage.
    #+BEGIN_SRC emacs-lisp
    (setq mode-line-percent-position nil)
    (column-number-mode 1)
    (line-number-mode 1)
    #+END_SRC

*** Indentation
    Display information about the current indentation settings.
    #+BEGIN_SRC emacs-lisp
    (use-package indent-info
      :defer 2
      :custom
      (indent-info-insert-target 'mode-line-mule-info)
      (indent-info-prefix " ")
      (indent-info-suffix " ")
      :config
      (global-indent-info-mode 1))
    #+END_SRC

*** Hide mode line
    Support hiding the mode line, this can be useful for different modes displaying
    documents or presentation.
    #+BEGIN_SRC emacs-lisp
    (use-package hide-mode-line)
    #+END_SRC

*** Diminished modes
    Hide minor modes to save space.
    #+BEGIN_SRC emacs-lisp
    (diminish 'abbrev-mode)
    (diminish 'auto-fill-function)
    (with-eval-after-load 'face-remap (diminish 'buffer-face-mode))
    (with-eval-after-load 'with-editor (diminish 'with-editor-mode))
    #+END_SRC

*** Icons
**** Modified
     #+BEGIN_SRC emacs-lisp
     (defun mode-line-modified-icons ()
       "Icon representation of `mode-line-modified'."
       (cond (buffer-read-only
              (concat (all-the-icons-octicon "lock" :v-adjust -0.05) " "))
             ((buffer-modified-p)
              (concat (all-the-icons-faicon "floppy-o" :v-adjust -0.05) " "))
             ((and buffer-file-name
                   (not (file-exists-p buffer-file-name)))
              (concat (all-the-icons-octicon "circle-slash" :v-adjust -0.05) " "))))

     (with-eval-after-load 'all-the-icons
       (setq-default mode-line-modified '((:eval (mode-line-modified-icons)))))
     #+END_SRC

**** Remote
     #+BEGIN_SRC emacs-lisp
     (defun mode-line-remote-icons ()
       "Icon representation of `mode-line-remote'."
       (when (and buffer-file-name
                  (file-remote-p buffer-file-name))
         (concat (all-the-icons-octicon "radio-tower" :v-adjust -0.02) " ")))

     (with-eval-after-load 'all-the-icons
       (setq-default mode-line-remote   '((:eval (mode-line-remote-icons)))))
     #+END_SRC

**** VCS
     Shorten long Git branch names as well as replace Git prefix with a nice icon.
     #+BEGIN_SRC emacs-lisp
     (defun +shorten-vc-mode-line (string)
       "Shorten `version-control' STRING in mode-line and add icon."
       (cond
        ((string-prefix-p "Git" string)
         (concat (all-the-icons-octicon "git-branch" :v-adjust -0.05)
                 " "
                 (if (> (length string) 30)
                     (concat (substring-no-properties string 4 30) "…")
                   (substring-no-properties string 4))))
        (t
         string)))
     (advice-add 'vc-git-mode-line-string :filter-return #'+shorten-vc-mode-line)
     #+END_SRC

* Display
** Frame
   Don't implicitly resize frames when changes various settings.
   #+BEGIN_SRC emacs-lisp
   (setq frame-inhibit-implied-resize t)
   #+END_SRC

** Window
*** Favor horizontal splits
    #+BEGIN_SRC emacs-lisp
    (setq split-width-threshold nil)
    #+END_SRC

*** Manage layouts
    Undo/redo between window layouts.
    #+BEGIN_SRC emacs-lisp
    (use-package winner
      :hook
      (window-setup . winner-mode)
      :custom
      (winner-dont-bind-my-keys t)
      :config
      (general-define-key
       :prefix +next-prefix
       +next-prefix (defrepeater #'winner-redo))
      (general-define-key
       :prefix +prev-prefix
       +prev-prefix (defrepeater #'winner-undo)))
    #+END_SRC

    Transpose window arrangement.
    #+BEGIN_SRC emacs-lisp
    (use-package transpose-frame
      :general
      (:prefix
       +window-prefix
       "t" 'transpose-frame))
    #+END_SRC

*** Navigation
    #+BEGIN_SRC emacs-lisp
    (use-package ace-window
      :custom
      (aw-ignore-current t)
      (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
      (aw-scope 'frame)
      :general
      ([remap other-window] 'ace-window))
    #+END_SRC

*** Zoom
    Zoom a window to display as a single window temporarily.
    #+BEGIN_SRC emacs-lisp
    (use-package zoom-window
      :general
      (:prefix
       +window-prefix
       "z" 'zoom-window-zoom))
    #+END_SRC

** Buffer
*** Hide async shell command buffers
    #+BEGIN_SRC emacs-lisp
    (cl-pushnew '("^*Async Shell Command*" . (display-buffer-no-window))
                display-buffer-alist
                :test #'equal)
    #+END_SRC

*** Popups
    Always display pop up buffers at the bottom and regard all star buffers as such
    buffers.
    #+BEGIN_SRC emacs-lisp
    (let ((rule `(,(rx bos "*" (one-or-more anything) "*" (optional "<" (one-or-more anything) ">") eos)
                  (display-buffer-reuse-window
                   display-buffer-in-side-window)
                  (reusable-frames . visible)
                  (side . bottom)
                  (window-height . 0.4))))
      (cl-pushnew rule display-buffer-alist :test #'equal))
    #+END_SRC

*** Visual Fill Column
    Wrap lines according to =fill-column= in =visual-line-mode=.
    #+BEGIN_SRC emacs-lisp
    (use-package visual-fill-column
      :custom
      (visual-fill-column-center-text t))
    #+END_SRC

* Editing
** Indentation
   Default to indentation by spaces, that seems to be what most languages use nowadays.
   #+BEGIN_SRC emacs-lisp
   (setq-default indent-tabs-mode nil)
   #+END_SRC

   Convert between tabs and spaces (only tabify initial whitespace)
   #+BEGIN_SRC emacs-lisp
   (setq-default tabify-regexp "^\t* [ \t]+")
   #+END_SRC

** Text flow
   Wrap at words and don't require double spaces to end a sentence.
   #+BEGIN_SRC emacs-lisp
   (setq sentence-end-double-space nil)
   (setq-default word-wrap t)
   #+END_SRC

   Disable line wrapping. But enable =visual-line-mode= by default to be able to use
   =global-visual-fill-column-mode=.
   #+BEGIN_SRC emacs-lisp
   (setq-default truncate-lines t)
   (add-hook 'visual-line-mode-hook #'turn-on-truncate-lines)
   (global-visual-line-mode 1)
   #+END_SRC

** Kill-ring
   Save clipboard contents into kill-ring before replacing them
   #+BEGIN_SRC emacs-lisp
   (setq save-interprogram-paste-before-kill t)
   #+END_SRC

** Packages
*** avy
    Jump to things.
    #+BEGIN_SRC emacs-lisp
    (use-package avy
      :custom
      (avy-all-windows nil)
      :general
      (:prefix
       +search-prefix
       "SPC" 'avy-goto-word-or-subword-1
       "s" 'avy-goto-char
       "l" 'avy-goto-line
       "m" 'avy-pop-mark))
    #+END_SRC

*** cycle-quotes
    #+BEGIN_SRC emacs-lisp
    (use-package cycle-quotes
      :commands
      (cycle-quotes)
      :preface
      (defrepeater #'cycle-quotes)
      :general
      ("C-x C-'" 'cycle-quotes-repeat))
    #+END_SRC

*** goto-addr
    Buttonize URLs and e-mail addresses in the current buffer.
    #+BEGIN_SRC emacs-lisp
    (use-package goto-addr
      :hook
      (text-mode . goto-address-mode)
      (prog-mode . goto-address-prog-mode))
    #+END_SRC

*** parrot
    Cycle through words, symbols and patterns.
    #+BEGIN_SRC emacs-lisp
    (use-package parrot
      :commands
      (parrot-rotate-next-word-at-point
       parrot-rotate-prev-word-at-point)
      :preface
      (defrepeater #'parrot-rotate-next-word-at-point)
      (defrepeater #'parrot-rotate-prev-word-at-point)
      :general
      (:prefix
       +next-prefix
       "r" '(parrot-rotate-prev-word-at-point-repeat :wk "Rotate word"))
      (:prefix
       +prev-prefix
       "r" '(parrot-rotate-prev-word-at-point-repeat :wk "Rotate word"))
      :config
      (dolist (entry '((:rot ("assert" "refute"))))
        (cl-pushnew entry parrot-rotate-dict :test #'equal)))
    #+END_SRC

*** string-inflection-cycle
    #+BEGIN_SRC emacs-lisp
    (use-package string-inflection
      :general
      ("M-'" 'string-inflection-all-cycle))
    #+END_SRC

*** smartparens
    Auto-insert matching parenthesis and highlight matching parenthesis.
    #+BEGIN_SRC emacs-lisp
    (use-package smartparens
      :diminish
      (smartparens-mode smartparens-strict-mode)
      :hook
      (eval-expression-minibuffer-setup . smartparens-strict-mode)
      :general
      (:prefix
       +toggle-prefix
       "p" 'smartparens-strict-mode)
      (:keymaps
       'smartparens-mode-map
       "M-D" 'sp-unwrap-sexp
       "M-R" 'sp-rewrap-sexp)
      :preface
      (defun +smartparens-no-autoinsert-pair-advice (orig-fn &rest args)
        "Disable command smartparens autoinsert when running ORIG-FN with ARGS."
        (let ((sp-autoinsert-pair nil))
          (apply orig-fn args)))
      :init
      (smartparens-global-strict-mode 1)
      (show-smartparens-global-mode 1)
      :config
      (require 'smartparens-config)
      (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)
      (with-eval-after-load 'hippie-exp
        (advice-add #'hippie-expand :around #'+smartparens-no-autoinsert-pair-advice)))
    #+END_SRC

*** visual-regexp
    Visually highlight regular expression searches as you type. Also supports replace.
    #+BEGIN_SRC emacs-lisp
    (use-package visual-regexp
      :general
      ("M-s r" 'vr/query-replace
       "M-s R" 'vr/replace))
    #+END_SRC

*** whitespace
    Display whitespace
    #+BEGIN_SRC emacs-lisp
    (use-package whitespace
      :custom
      (whitespace-line-column fill-column)
      (whitespace-style
       '(face tabs tab-mark spaces space-mark trailing lines-tail))
      (whitespace-display-mappings
       '((tab-mark ?\t [?› ?\t])
         (newline-mark 10 [?¬ 10])
         (space-mark 32 [183] [46]))))
    #+END_SRC

*** whole-line-or-region
    Cut/copy (=C-w= / =M-w=) the current line if no region is active.
    #+BEGIN_SRC emacs-lisp
    (use-package whole-line-or-region
      :diminish whole-line-or-region-local-mode
      :init
      (whole-line-or-region-global-mode 1))
    #+END_SRC

*** yasnippet
    #+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :defer 1
      :diminish yas-minor-mode
      :commands
      (yas--templates-for-key-at-point)
      :custom
      (yas-also-auto-indent-first-line t)
      (yas-snippet-dirs (list (expand-file-name "snippets" user-emacs-directory)))
      ;; Nested snippets
      (yas-triggers-in-field t)
      (yas-wrap-around-region t)
      :general
      (:keymaps
       'yas-minor-mode-map
       [tab] 'nil
       "TAB" 'nil)
      :init
      (setq yas-verbosity 0)
      :config
      (yas-global-mode 1))

    (use-package yasnippet-snippets
      :defer 2)
    #+END_SRC

*** yatemplate
    #+BEGIN_SRC emacs-lisp
    (use-package autoinsert
      :defer 1
      :custom
      (auto-insert-query nil)
      (auto-insert-alist nil)
      :config
      (auto-insert-mode 1))

    (use-package yatemplate
      :init
      (yatemplate-fill-alist))
    #+END_SRC

** Appearance
*** Page breaks
    Display page breaks as a horizontal line.
    #+BEGIN_SRC emacs-lisp
    (use-package page-break-lines
      :defer 1
      :diminish page-break-lines-mode
      :config
      (global-page-break-lines-mode 1))
    #+END_SRC

*** Line highlight
    #+BEGIN_SRC emacs-lisp
    (use-package hl-line
      :hook
      ((prog-mode conf-mode) . hl-line-mode)
      :custom
      ;; Only highlight in selected window
      (hl-line-sticky-flag nil)
      (global-hl-line-sticky-flag nil))
    #+END_SRC

* Buffers
  Prevent generation of useless lock and backup files.
  #+BEGIN_SRC emacs-lisp
  (setq create-lockfiles nil
        make-backup-files nil)
  #+END_SRC

  Don't require confirmation when opening a new buffer.
  #+BEGIN_SRC emacs-lisp
  (setq confirm-nonexistent-file-or-buffer t)
  #+END_SRC

  Remove visual indicators from non-selected windows
  #+BEGIN_SRC emacs-lisp
  (setq highlight-nonselected-windows nil)
  (setq-default cursor-in-non-selected-windows nil)
  #+END_SRC

** Auto save
   Disable auto save to avoid unwanted save hooks being triggered. Such as formatting etc.
   #+BEGIN_SRC emacs-lisp
   (auto-save-visited-mode 0)
   (setq save-abbrevs 'silently)
   #+END_SRC

** Auto executable scripts
   #+BEGIN_SRC emacs-lisp
   (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
   #+END_SRC

** Minibuffer
   Enable recursive minibuffers and keep the point out of the minibuffer.
   #+BEGIN_SRC emacs-lisp
   (setq enable-recursive-minibuffers t
         minibuffer-prompt-properties
         '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt))
   #+END_SRC

   Give some more room to the minbuffer.
   #+BEGIN_SRC emacs-lisp
   (setq max-mini-window-height 0.3
         resize-mini-windows 'grow-only)
   #+END_SRC

*** No fringes
    Don't show fringes in the minibuffer.
    #+BEGIN_SRC emacs-lisp
    (defun +disable-minibuffer-window-fringes (&optional frame)
      "Disable the window fringes for minibuffer window."
      (let ((target (if frame frame (selected-frame))))
        (with-selected-frame target
          (set-window-fringes (minibuffer-window) 0 0 nil))))
    (add-hook 'after-make-frame-functions #'+disable-minibuffer-window-fringes)
    (add-hook 'minibuffer-setup-hook #'+disable-minibuffer-window-fringes)
    #+END_SRC

*** History
    Track minibuffer history
    #+BEGIN_SRC emacs-lisp
    (setq history-delete-duplicates t
          history-length 500)
    #+END_SRC

*** Miniedit
    Edit minibuffer in a new temporary buffer by pressing =C-c '=.
    #+BEGIN_SRC emacs-lisp
    (use-package miniedit
      :general
      (:keymaps
       '(minibuffer-local-map
         minibuffer-local-ns-map
         minibuffer-local-completion-map
         minibuffer-local-must-match-map)
       "C-c '" 'miniedit))
    #+END_SRC

** Scrolling
   More procedural scrolling.
   #+BEGIN_SRC emacs-lisp
   (setq auto-window-vscroll nil
         hscroll-margin 5
         hscroll-step 5
         scroll-conservatively 101
         scroll-margin 0
         scroll-preserve-screen-position t)

   (setq-default scroll-down-aggressively 0.01
                 scroll-up-aggressively 0.01)
   #+END_SRC

** Packages
*** autorevert
    Revert buffers when underlying files change.
    #+BEGIN_SRC emacs-lisp
    (use-package autorevert
      :custom
      (auto-revert-verbose nil))
    #+END_SRC

*** default-text-scale
    #+BEGIN_SRC emacs-lisp
    (use-package default-text-scale
      :general
      ("C-M-=" 'default-text-scale-increase)
      ("C-M--" 'default-text-scale-decrease)
      ("C-M-0" 'default-text-scale-reset))
    #+END_SRC

*** eldoc
    #+BEGIN_SRC emacs-lisp
    (use-package eldoc
      :diminish eldoc-mode
      :config
      (global-eldoc-mode 1))
    #+END_SRC

*** eldoc-posframe
    Display eldoc in a child frame.
    #+BEGIN_SRC emacs-lisp
    (use-package eldoc-posframe
      :diminish eldoc-posframe-mode
      :custom
      (eldoc-posframe-left-fringe 0)
      (eldoc-posframe-poshandler #'posframe-poshandler-point-bottom-left-corner))
    #+END_SRC

*** rainbow-mode
    Display colors inline.
    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-mode
	;; :minor
	;; "-theme\\.el$"
	:hook
	help-mode)
    #+END_SRC

*** readable
    #+BEGIN_SRC emacs-lisp
    (use-package readable
      :diminish readable-mode
      :hook
      ((eww-mode
        markdown-mode
        nov-mode
        org-mode
        rst-mode) . readable-mode))
    #+END_SRC

*** relative-buffers
    #+BEGIN_SRC emacs-lisp
    (use-package relative-buffers
      :demand t
      :custom
      (relative-buffers-project-prefix t)
      :config
      (global-relative-buffers-mode 1))
    #+END_SRC

*** spray
    #+BEGIN_SRC emacs-lisp
    (use-package spray
      :custom
      (spray-height 500)
      (spray-margin-left 2)
      :config
      (setq spray-unsupported-minor-modes
            (append '(beacon-mode centered-window-mode visual-fill-column-mode)
                    spray-unsupported-minor-modes)))
    #+END_SRC

*** wgrep-ag
    Writeable grep buffer with ability to apply the changes to all the files.
    #+BEGIN_SRC emacs-lisp
    (use-package wgrep-ag
      :custom
      (wgrep-auto-save-buffer t))
    #+END_SRC

* Navigation
   Allow repeated mark popping. This behavior is similar to Vim's =C-o=. With this
   configuration you can press =C-u= and continuously =C-SPC= to jump to previous entries in
   the mark ring.
   #+BEGIN_SRC emacs-lisp
   (setq set-mark-command-repeat-pop t)
   #+END_SRC

** Dired
   #+BEGIN_SRC emacs-lisp
   (use-package dired
     :hook
     (dired-mode . auto-revert-mode)
     (dired-mode . hl-line-mode)
     (dired-mode . dired-hide-details-mode)
     :custom
     (dired-listing-switches "-al --group-directories-first")
     ;; Always copy/delete recursively
     (dired-recursive-copies  'always)
     (dired-recursive-deletes 'top))
   #+END_SRC

*** Editable
    #+BEGIN_SRC emacs-lisp
    (use-package wdired
      :preface
      (defvar-local +wdired-icons-enabled nil)
      (defun +wdired-before-start-advice ()
        "Execute when switching from `dired' to `wdired'."
        (setq +wdired-icons-enabled (if (bound-and-true-p all-the-icons-dired-mode)
                                        1 0))
        (when (bound-and-true-p all-the-icons-dired-mode)
          (all-the-icons-dired-mode 0)))
      (defun +wdired-after-finish-advice ()
        "Execute when switching from `wdired' to `dired'"
        (when (boundp 'all-the-icons-dired-mode)
          (all-the-icons-dired-mode +wdired-icons-enabled)))
      (advice-add 'wdired-change-to-wdired-mode :before #'+wdired-before-start-advice)
      (advice-add 'wdired-change-to-dired-mode :after #'+wdired-after-finish-advice)
      :general
      (:keymaps
       'dired-mode-map
       "C-c '" 'wdired-change-to-wdired-mode))
    #+END_SRC

*** Sidebar
    #+BEGIN_SRC emacs-lisp
    (use-package dired-sidebar
      :hook
      (dired-sidebar-mode . hide-mode-line-mode)
      (dired-sidebar-mode . hl-line-mode)
      (dired-sidebar-mode . variable-pitch-mode)
      (dired-sidebar-mode . +dired-sidebar-setup)
      :general
      (:prefix
       +leader-key
       "n" 'dired-sidebar-toggle-sidebar)
      :preface
      (defun +dired-sidebar-setup ()
        (setq cursor-type nil)
        (stripe-buffer-mode 0)))
    #+END_SRC

*** Subtree
    Display subtrees in dired view.
    #+BEGIN_SRC emacs-lisp
    (use-package dired-subtree
      :custom
      (dired-subtree-use-backgrounds nil)
      (dired-subtree-line-prefix "     "))
    #+END_SRC

*** Stripes
    Striped dired buffers.
    #+BEGIN_SRC emacs-lisp
    (use-package stripe-buffer
      :hook
      (dired-mode . stripe-buffer-mode))
    #+END_SRC

*** Icons
    #+BEGIN_SRC emacs-lisp
    (use-package all-the-icons-dired
      :diminish all-the-icons-dired-mode
      :hook
      (dired-mode . all-the-icons-dired-mode))
    #+END_SRC

*** Git
    #+BEGIN_SRC emacs-lisp
    (use-package dired-git-info
      :general
      (:keymaps
       'dired-mode-map
       ")" 'dired-git-info-mode))
    #+END_SRC

** Packages
*** ace-link
    Hint mode for links.
    #+BEGIN_SRC emacs-lisp
    (use-package ace-link
      :general
      (:prefix
       +search-prefix
       "o" 'ace-link)
      (:keymaps
       '(help-mode-map helpful-mode-map)
       "o" 'ace-link-help))
    #+END_SRC

*** bibliothek
    Management tool for a library of PDFs.
    #+BEGIN_SRC emacs-lisp
    (use-package bibliothek
      :custom
      (bibliothek-path '("~/books" "~/documents/research/papers"))
      (bibliothek-recursive t)
      :general
      (:prefix
       +launch-prefix
       "b" 'bibliothek))
    #+END_SRC

*** bookmark
    Keep track of bookmarks
    #+BEGIN_SRC emacs-lisp
    (use-package bookmark
      :custom
      (bookmark-save-flag 1))
    #+END_SRC

*** deadgrep
    #+BEGIN_SRC emacs-lisp
    (use-package deadgrep
      :general
      (:prefix
       +search-prefix
       "G" 'deadgrep)
      (:keymaps
       'deadgrep-mode-map
       "C-c '" 'deadgrep-edit-mode))
    #+END_SRC

*** deft
    #+BEGIN_SRC emacs-lisp
    (use-package deft
      :custom
      (deft-auto-save-interval 0)
      (deft-directory (expand-file-name "~/org/"))
      (deft-extensions '("org" "md" "rst" "txt" "tex"))
      (deft-recursive t)
      (deft-use-filename-as-title t)
      (deft-use-filter-string-for-filename t)
      :general
      (:prefix
       +launch-prefix
       "n" 'deft))
    #+END_SRC

*** find-file
    #+BEGIN_SRC emacs-lisp
    (use-package find-file
      :init
      (setq-default ff-quiet-mode t)
      (put 'ff-search-directories 'safe-local-variable (lambda (x) (seq-every-p #'stringp x))))

    (use-package ff-test
      :demand t)
    #+END_SRC

*** goto-last-change
    Move point through buffer-undo-list positions.
    #+BEGIN_SRC emacs-lisp
    (use-package goto-chg
      :general
      (:prefix
       +next-prefix
       "l" '(goto-last-change :wk "Change"))
      (:prefix
       +prev-prefix
       "l" '(goto-last-change-reverse :wk "Change")))
    #+END_SRC

*** recentf
    Keep track of recently opened files.
    #+BEGIN_SRC emacs-lisp
    (use-package recentf
      :defer 2
      :custom
      (recentf-exclude
       (list "/tmp/"                        ; Temp-files
             "/dev/shm"                     ; Potential secrets
             "/ssh:"                        ; Files over SSH
             "/TAGS$"                       ; Tag files
             "^/\\.git/.+$"                 ; Git contents
             "\\.?ido\\.last$"
             "\\.revive$"
             "^/var/folders/.+$"
             (concat "^" +cache-dir ".+$")
             (concat "^" +data-dir ".+$")))
      (recentf-filename-handlers '(abbreviate-file-name))
      (recentf-max-menu-items 0)
      (recentf-max-saved-items 300)
      (recentf-auto-cleanup 'never)
      :config
      (quiet! (recentf-mode 1)))
    #+END_SRC

*** saveplace
    Keep track of last point place to resume editing in the same file.
    #+BEGIN_SRC emacs-lisp
    (use-package saveplace
      :defer 2
      :config
      (save-place-mode 1))
    #+END_SRC

** Project
   Project interactions. Prefix project buffer files with the project name and relative path.
   #+BEGIN_SRC emacs-lisp
   (use-package projectile
     :demand t
     :diminish projectile-mode
     :custom
     (projectile-enable-caching nil)
     (projectile-file-exists-remote-cache-expire nil)
     (projectile-globally-ignored-file-suffixes
      '(".elc" ".pyc" ".o" ".hi" ".class" ".cache"))
     (projectile-globally-ignored-files
      '("TAGS" "GPATH" "GRTAGS" "GTAGS"))
     (projectile-ignored-projects (list +data-dir))
     (projectile-indexing-method 'alien)
     :general
     (:keymaps
      'projectile-mode-map
      [remap eshell] (general-predicate-dispatch #'eshell
                       :docstring "Creat an interactive Eshell buffer (project aware)"
                       (projectile-project-p) #'projectile-run-eshell)
      [remap term] (general-predicate-dispatch #'term
                     :docstring "Create an interactive terminal buffer (project aware)"
                     (projectile-project-p) #'projectile-run-term))
     (:keymaps
      'projectile-mode-map
      :prefix
      +leader-key
      "p" '(:keymap projectile-command-map :package projectile :wk "project"))
     :init
     (defun +projectile-cache-current-file (orig-fun &rest args)
       "Don't cache ignored files."
       (unless (cl-some (lambda (path)
                          (string-prefix-p buffer-file-name
                                           (expand-file-name path)))
                        (projectile-ignored-directories))
         (apply orig-fun args)))
     (advice-add #'projectile-cache-current-file :around #'+projectile-cache-current-file)
     (cl-pushnew '(setq projectile-project-root (locate-dominating-file buffer-file-name ".dir-locals.el"))
                 safe-local-eval-forms
                 :test #'equal)
     :config
     (setq projectile-globally-ignored-directories
           (append '("_build"
                     "target" "project/target"
                     "vendor/bundle" "vendor/cache"
                     "elm-stuff" "tests/elm-stuff")
                   projectile-globally-ignored-directories))
     (setq projectile-other-file-alist
           (append '(("less" "css")
                     ("styl" "css")
                     ("sass" "css")
                     ("scss" "css")
                     ("css" "scss" "sass" "less" "styl")
                     ("jade" "html")
                     ("pug" "html")
                     ("html" "jade" "pug" "jsx" "tsx"))
                   projectile-other-file-alist))
     (setq projectile-project-root-files
           (append '("package.json" "Package.swift" "README.md")
                   projectile-project-root-files))

     (projectile-mode 1))
   #+END_SRC

   Manage project repositories.
   #+BEGIN_SRC emacs-lisp
   (use-package ivy-ghq
     :defer 2
     :custom
     (ivy-ghq-short-list t))
   #+END_SRC

* Completion
  Enable completion with tab
  #+BEGIN_SRC emacs-lisp
  (setq tab-always-indent t)
  #+END_SRC

** Company
   #+BEGIN_SRC emacs-lisp
   (use-package company
     :custom
     (company-show-numbers t)
     (company-backends
      '((company-files
         company-keywords
         company-capf)))
     :hook
     (prog-mode . company-mode)
     :general
     (:keymaps
      'company-mode-map
      "C-?" 'company-complete)
     (:keymaps
      'company-active-map
      ;; No interference with return key
      [return]  'nil
      "RET"     'nil
      "C-e" 'company-complete-selection
      "C-f" 'company-complete-selection
      "C-n" 'company-select-next
      "C-p" 'company-select-previous))
   #+END_SRC

** Hippie
   Smart expansion completions, excellent for completing lines.
   Replace abbrev completion (=M-/=) with hippie expand.

   Complete in the following order:
   - Try to expand word "dynamically", searching the current buffer.
   - Try to expand word "dynamically", searching all other buffers.
   - Try to expand word "dynamically", searching the kill ring.
   - Try to complete text as a file name, as many characters as unique.
   - Try to complete text as a file name.
   - Try to expand word before point according to all abbrev tables.
   - Try to complete the current line to an entire line in the buffer.
   - Try to complete as an Emacs Lisp symbol, as many characters as unique.
   - Try to complete word as an Emacs Lisp symbol.
   #+BEGIN_SRC emacs-lisp
   (use-package hippie-exp
     :custom
     (hippie-expand-try-functions-list
      '(try-expand-dabbrev-visible
        try-expand-dabbrev
        try-complete-file-name-partially
        try-complete-file-name
        try-expand-all-abbrevs
        try-expand-list
        try-expand-line
        try-expand-line-all-buffers
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol))
     :general
     ([remap dabbrev-expand] 'hippie-expand))
   #+END_SRC

** Ivy
   #+BEGIN_SRC emacs-lisp
   (use-package ivy
     :diminish ivy-mode
     :hook (after-init . ivy-mode)
     :custom
     (ivy-wrap t)
     (ivy-on-del-error-function #'ignore)
     (ivy-use-virtual-buffers t)
     ;; Allow selecting the prompt as a candidate (e.g for creating a new file)
     (ivy-use-selectable-prompt t)
     (ivy-fixed-height-minibuffer t)
     ;; Highlight whole line
     (ivy-format-function #'ivy-format-function-line)
     :general
     (:keymaps
      'ivy-mode-map
      [remap switch-to-buffer] 'ivy-switch-buffer
      "C-c C-r"                'ivy-resume)
     (:keymaps
      'ivy-mode-map
      :prefix
      +window-prefix
      "v" 'ivy-push-view
      "V" 'ivy-pop-view
      "'" 'ivy-switch-view)
     (:keymaps
      'ivy-occur-grep-mode-map
      "C-c '" 'ivy-wgrep-change-to-wgrep-mode)
     (:keymaps
      'ivy-minibuffer-map
      "M-v"    'yank
      "M-z"    'undo
      "C-k"    'ivy-previous-line
      "C-j"    'ivy-next-line
      "C-l"    'ivy-alt-done
      "C-w"    'ivy-backward-kill-word
      "C-u"    'ivy-kill-line
      "C-e"    '+ivy-move-end-of-line-or-done
      "C-f"    'ivy-alt-done)
     :preface
     (defun +ivy-move-end-of-line-or-done (arg)
       "Move to end of current line or consider ivy operation done.
      ARG lines can be used."
       (interactive "p")
       (if (eolp)
           (ivy-alt-done)
         (move-end-of-line arg)))
     :init
     ;; Don't use ^ as initial input
     (setq ivy-initial-inputs-alist nil)

     (setq-default
      dumb-jump-selector             'ivy
      magit-completing-read-function #'ivy-completing-read
      projectile-completion-system   'ivy
      smex-completion-method         'ivy))
    #+END_SRC

*** Packages
**** counsel
     Replacements for common Emacs commands. =smex= is used by =counsel-M-x= for sorting.
     Tips:
     - =counsel-rg= can be used with =C-u= to search in a specific directory.
     #+BEGIN_SRC emacs-lisp
     (use-package smex
       :custom
       (smex-auto-update nil))

     (use-package counsel
       :diminish counsel-mode
       :hook (ivy-mode . counsel-mode)
       :custom
       (counsel-find-file-ignore-regexp
        "\\(?:^[#.]\\)\\|\\(?:[#~]$\\)\\|\\(?:^Icon?\\)")
       (counsel-grep-base-command
        "rg -i -M 120 --no-heading --line-number --color never '%s' %s")
       (counsel-mode-override-describe-bindings t)
       :general
       ;; Use counsel/swiper for search
       ("C-s" 'swiper-isearch)
       ("C-x /" 'counsel-abbrev)
       (:keymaps
        'counsel-mode-map
        "C-c p" 'counsel-git
        "C-c r" 'counsel-recentf)
       (:keymaps
        'counsel-mode-map
        :prefix +search-prefix
        "g" 'counsel-rg
        "i" 'counsel-imenu)
       (:keymaps
        'counsel-ag-map
        "C-SPC" 'ivy-call-and-recenter)
       :config
       (defun counsel-abbrev (abbrev-name)
         "Insert abbreviation matching ABBREV-NAME."
         (interactive
          (list
           (ivy-completing-read
            "Insert abbrev: "
            (cl-loop for table in (abbrev--active-tables)
                     unless (abbrev-table-empty-p table)
                     append (append (delete 0 table) ())))))
         (progn
           (dolist (table (abbrev--active-tables))
             (when (abbrev-symbol abbrev-name table)
               (abbrev-insert (abbrev-symbol abbrev-name table))))))

       (defun counsel-git-expanded-cands ()
         (let ((root (counsel--git-root)))
           (when root
             (mapcar
              (lambda (f) (expand-file-name f root))
              (counsel-git-cands)))))

       (ivy-set-sources
        'counsel-recentf
        '((original-source)
          (counsel-git-expanded-cands))))
     #+END_SRC

**** swiper
     I-search replacement with overview
     #+BEGIN_SRC emacs-lisp
     (use-package swiper)
     #+END_SRC

**** flyspell-correct-ivy
     #+BEGIN_SRC emacs-lisp
     (use-package flyspell-correct-ivy
       :general
       (:prefix
        +next-prefix
        "S" '(flyspell-correct-word-generic :wk "Spell fix"))
       (:prefix
        +prev-prefix
        "S" '(flyspell-correct-previous-word-generic :wk "Spell fix")))
     #+END_SRC

**** imenu-anywhere
     Jump to document locations in current buffer
     #+BEGIN_SRC emacs-lisp
     (use-package imenu-anywhere
       :general
       (:keymaps
        'ivy-mode-map
        [remap imenu-anywhere] 'ivy-imenu-anywhere)
       (:keymaps
        'ivy-mode-map
        :prefix +search-prefix
        "I" 'ivy-imenu-anywhere))
     #+END_SRC

**** ivy-xref
     Support =xref= lookups.
     #+BEGIN_SRC emacs-lisp
     (use-package ivy-xref
       :init
       (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
     #+END_SRC

**** ivy-yasnippet
     Snippets with preview.
     #+BEGIN_SRC emacs-lisp
     (use-package ivy-yasnippet
       :general
       ([remap yas-insert-snippet] 'ivy-yasnippet)
       (:prefix
        +leader-key
        "y" 'ivy-yasnippet))
     #+END_SRC

**** counsel-tramp
     Navigate tramp files.
     #+BEGIN_SRC emacs-lisp
     (use-package counsel-tramp
       :general
       (:prefix
        +leader-key
        "t" 'counsel-tramp))
     #+END_SRC

*** Icons
    #+BEGIN_SRC emacs-lisp
    (use-package all-the-icons-ivy
      :defer 1
      :after
      (ivy counsel)
      :config
      (all-the-icons-ivy-setup))
    #+END_SRC

* Development
   Reduce scroll margin.
   #+BEGIN_SRC emacs-lisp
   (defun +prog-scroll-margin-setup ()
     "Setup `scroll-margin' for `prog-mode'."
     (setq-local scroll-margin 3))
   (add-hook 'prog-mode-hook #'+prog-scroll-margin-setup)
   #+END_SRC

** Compilation
   Kill compilation process before stating another and save all buffers on =compile.=
   #+BEGIN_SRC emacs-lisp
   (use-package compile
     :custom
     (compilation-always-kill t)
     (compilation-ask-about-save nil)
     (compilation-scroll-output t)
     :general
     (:keymaps
      'global
      :prefix
      +local-leader-key
      "c" 'recompile
      "C" 'compile)
     :init
     (make-variable-buffer-local 'compile-command)
     (put 'compile-command 'safe-local-variable 'stringp))
   #+END_SRC

*** ANSI escape
    #+BEGIN_SRC emacs-lisp
    (require 'ansi-color)
    (defun +colorize-compilation ()
      "Colorize from `compilation-filter-start' to `point'."
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region compilation-filter-start (point))))
    (add-hook 'compilation-filter-hook #'+colorize-compilation)
    #+END_SRC

** Containers
*** Docker
     #+BEGIN_SRC emacs-lisp
     (use-package docker
       :general
       (:prefix
        +leader-key
        "d" 'docker
        "c" 'docker-compose))
    #+END_SRC

**** Files
     Support for Docker related files.
     #+BEGIN_SRC emacs-lisp
     (use-package dockerfile-mode)
     (use-package docker-compose-mode)
     #+END_SRC

**** Tramp
     #+BEGIN_SRC emacs-lisp
     (use-package docker-tramp
       :defer 2
       :custom
       (docker-tramp-use-names t))
     #+END_SRC

*** Kubernetes
    #+BEGIN_SRC emacs-lisp
    (use-package kubernetes)
    #+END_SRC

**** Tramp
     #+BEGIN_SRC emacs-lisp
     (use-package kubernetes-tramp
       :defer 2)
     #+END_SRC

** Coverage
   #+BEGIN_SRC emacs-lisp
   (use-package coverlay
     :diminish coverlay-minor-mode
     :custom
     (coverlay:mark-tested-lines nil)
     :init
     (defun +coverlay-mode-enable ()
       "Turn on `coverlay-mode'."
       (coverlay-minor-mode 1)
       (when (and (buffer-file-name) (not (bound-and-true-p coverlay--loaded-filepath)))
         (let* ((coverage-file (concat
                                (locate-dominating-file (file-name-directory (buffer-file-name)) "coverage")
                                "coverage"
                                "/lcov.info")))
           (when (file-exists-p coverage-file)
             (coverlay-watch-file coverage-file))))))
   #+END_SRC

** Docs
*** DevDocs
    Lookup documentation via DevDocs.
    #+BEGIN_SRC emacs-lisp
    (use-package devdocs
      :general
      ("M-g K" 'devdocs-search))
    #+END_SRC

** Eval
*** quickrun
    #+BEGIN_SRC emacs-lisp
    (use-package quickrun
      :hook
      (quickrun--mode . display-ctrl-M-as-newline)
      :general
      (:prefix
       +local-leader-key
       "q" 'quickrun
       "Q" 'quickrun-autorun-mode))
    #+END_SRC

** Folding
   Code folding.
   #+BEGIN_SRC emacs-lisp
   (use-package hideshow
     :diminish hs-minor-mode
     :hook (prog-mode . hs-minor-mode)
     :custom
     (hs-hide-comments-when-hiding-all nil)
     :general
     (:prefix
      (concat +leader-key " " "z")
      ""      '(:ignore t :wk "hide")
      "c"     'hs-hide-block
      "o"     'hs-show-block
      "C"     'hs-hide-all
      "O"     'hs-show-all
      "l"     'hs-hide-level
      "z"     'hs-toggle-hiding
      "<tab>" 'hs-toggle-hiding)
     :init
     (defun +hs-fold-overlay-ellipsis (ov)
       (when (eq 'code (overlay-get ov 'hs))
         (overlay-put
          ov 'display (propertize " … " 'face 'font-lock-comment-face))))

     (setq hs-allow-nesting t
           hs-set-up-overlay #'+hs-fold-overlay-ellipsis))
   #+END_SRC

** Formatting
*** aggressive-indent
    Automatic indentation as you type. It is a bit more robust than =electric-indent-mode=,
    but perhaps I should look into using that for those modes that are not compatible with
    =aggressive-indent-mode=.
    #+BEGIN_SRC emacs-lisp
    (use-package aggressive-indent
      :diminish aggressive-indent-mode
      :hook
      ((emacs-lisp-mode
        lisp-mode
        nix-mode) . aggressive-indent-mode))
    #+END_SRC

*** apheleia
    Reformat buffer without moving point.
    #+BEGIN_SRC emacs-lisp
    (use-package apheleia
      :defer 2
      :init
      (put 'apheleia-formatter 'safe-local-variable 'symbolp)
      :config
      (progn ;; JavaScript/TypeScript
        (cl-pushnew '(eslint . (npx "eslint_d" "--fix-to-stdout" "--stdin" "--stdin-filename" file)) apheleia-formatters :test #'equal))
      (progn ;; Terraform
        (cl-pushnew '(terraform . ("terraform" "fmt" "-")) apheleia-formatters :test #'equal)
        (cl-pushnew '(terraform-mode . terraform) apheleia-mode-alist :test #'equal))
      (apheleia-global-mode 1))
    #+END_SRC

*** reformatter
    Custom formatters.
    #+BEGIN_SRC emacs-lisp
    (use-package reformatter
      :demand t
      :config
      (reformatter-define prettier-typescript-format
        :program "prettier"
        :args '("--stdin" "--stdin-filepath=f.ts"))
      (reformatter-define javascript-format
        :program "eslint_d"
        :args '("--stdin" "--stdin-filename=f.js" "--fix-to-stdout"))
      (reformatter-define typescript-format
        :program "eslint_d"
        :args '("--stdin"  "--stdin-filename=f.ts" "--fix-to-stdout")))
    #+END_SRC

** Jump to definition
   Jump to definition is really useful and I prefer doing so without TAGS which is pretty
   much the default for most modes. I am using the excellent package =dumb-jump= to jump via
   grep tools e.g. (=grep=, =rx=, =ag=)

   Don't ask about keeping current list of tags tables.
   #+BEGIN_SRC emacs-lisp
   (use-package etags
     :custom
     (tags-add-tables nil))
   #+END_SRC

*** dumb-jump
    #+BEGIN_SRC emacs-lisp
    (use-package dumb-jump
      :custom
      (dumb-jump-default-project user-emacs-directory)
      :general
      (:prefix
       +nav-prefix
       "i" 'dumb-jump-go-prompt
       "o" 'dumb-jump-go-other-window
       "x" 'dumb-jump-go-prefer-external
       "z" 'dumb-jump-go-prefer-external-other-window))
    #+END_SRC

*** smart-jump
    Some modes actually have some good backends, so configure this with =smart-jump= which
    has nice defaults and also adds configuring completion with a fallback to =dumb-jump=.
    #+BEGIN_SRC emacs-lisp
    (use-package smart-jump
      :defer 2
      :custom
      (smart-jump-find-references-fallback-function #'+smart-jump-find-references-with-counsel-rg)
      (smart-jump-default-mode-list
       '(clojure-mode
         eglot
         elisp-mode
         elixir-mode
         elm-mode
         erlang-mode
         go-mode
         lisp-mode
         lua-mode
         python
         scala-mode))
      :general
      ("M-." 'smart-jump-go)
      ("M-," 'smart-jump-back)
      ("M-?" 'smart-jump-references)
      (:prefix
       +nav-prefix
       "j" 'smart-jump-go
       "r" 'smart-jump-references)
      :preface
      (defun +smart-jump-find-references-with-counsel-rg ()
        "Use `rg' and `counsel' to find references."
        (interactive)
        (if (fboundp 'counsel-rg)
            (counsel-rg
             (cond ((use-region-p)
                    (buffer-substring-no-properties (region-beginning)
                                                    (region-end)))
                   ((symbol-at-point)
                    (substring-no-properties
                     (symbol-name (symbol-at-point))))))
          (message "Install swiper to use `+smart-jump-simple-find-references-with-counsel-rg'.")))
      :config
      (smart-jump-setup-default-registers))
    #+END_SRC

** REPL
*** repl-toggle
    #+BEGIN_SRC emacs-lisp
    (use-package repl-toggle
      :custom
      (rtog/goto-buffer-fun 'pop-to-buffer)
      (rtog/mode-repl-alist '((emacs-lisp-mode . ielm)
                              (clojure-mode . clojure-repl)
                              (elm-mode . elm-repl-load)
                              (go-mode . gorepl-run)
                              (js-mode . js-repl)
                              (lisp-mode . slime)
                              (lua-mode . lua-repl)
                              (nix-mode . nix-repl)
                              (racket-mode . racket-repl)
                              (typescript-mode . run-ts)))
      :general
      (:keymaps
       'prog-mode-map
       :prefix +local-leader-key
       "r" 'rtog/toggle-repl)
      :preface
      (defun clojure-repl ()
        "Open a Clojure REPL."
        (interactive)
        (pop-to-buffer (cider-current-repl nil 'ensure)))

      (defun js-repl ()
        "Open a JavaScript REPL."
        (interactive)
        (if (indium-client-process-live-p) (indium-switch-to-repl-buffer) (nodejs-repl)))

      (defun lua-repl ()
        "Open a Lua REPL."
        (interactive)
        (pop-to-buffer (process-buffer (lua-get-create-process)))))
    #+END_SRC

*** Persistent history in comint
    #+BEGIN_SRC emacs-lisp
    (defun +comint-history-write-on-exit (process event)
      "Write `comint' history on exit.
    Receives PROCESS and EVENT."
      (comint-write-input-ring)
      (let ((buf (process-buffer process)))
        (when (buffer-live-p buf)
          (with-current-buffer buf
            (insert (format "\nProcess %s %s" process event))))))

    (defun +comint-history-enable ()
      "Enable `comint' history."
      (let ((process (get-buffer-process (current-buffer))))
        (when process
          (setq comint-input-ring-file-name
                (expand-file-name
                 (format "comint-%s-history" (process-name process))
                 +cache-dir))
          (comint-read-input-ring)
          (set-process-sentinel process #'+comint-history-write-on-exit))))
    #+END_SRC

** Syntax checker
   Silence next/previous error, by default it produces a message every time.
   #+BEGIN_SRC emacs-lisp
   (advice-add #'next-error :around #'quiet-function-advice)
   (advice-add #'previous-error :around #'quiet-function-advice)
   #+END_SRC

*** flymake
    Connect flymake to =next-error-function= and add some navigation bindings. Disable the
    legacy diagnostic functions as some of them have bugs and cause instability (mainly
    the Haskell one).
    #+BEGIN_SRC emacs-lisp
    (use-package flymake
      :hook
      (flymake-mode . +flymake-setup-next-error-function)
      :custom
      (help-at-pt-timer-delay 0.1)
      (help-at-pt-display-when-idle '(flymake-diagnostic))
      (flymake-proc-ignored-file-name-regexps '("\\.l?hs\\'"))
      :general
      (:keymaps
       'flymake-mode-map
       :prefix
       +local-leader-key
       "!" 'flymake-show-diagnostics-buffer)
      (:keymaps
       'flymake-mode-map
       :prefix +next-prefix
       "E" 'flymake-goto-next-error)
      (:keymaps
       'flymake-mode-map
       :prefix +prev-prefix
       "E" 'flymake-goto-prev-error)
      (:keymaps
       'flymake-diagnostics-buffer-mode-map
       "n" '+flymake-diagnostics-next-error
       "p" '+flymake-diagnostics-prev-error
       "j" '+flymake-diagnostics-next-error
       "k" '+flymake-diagnostics-prev-error
       "RET" 'flymake-goto-diagnostic
       "TAB" 'flymake-show-diagnostic)
      :preface
      (defun +flymake-setup-next-error-function ()
        (setq next-error-function 'flymake-goto-next-error))

      (defun +flymake-diagnostics-next-error ()
        (interactive)
        (forward-line)
        (when (eobp) (forward-line -1))
        (flymake-show-diagnostic (point)))

      (defun +flymake-diagnostics-prev-error ()
        (interactive)
        (forward-line -1)
        (flymake-show-diagnostic (point)))
      :init
      (remove-hook 'flymake-diagnostic-functions 'flymake-proc-legacy-flymake))
    #+END_SRC

**** Diagnostics at point
     #+BEGIN_SRC emacs-lisp
     (use-package flymake-diagnostic-at-point
       :hook
       (flymake-mode . flymake-diagnostic-at-point-mode)
       :preface
       (defun flymake-diagnostic-at-point-quick-peek (text)
         "Display the flymake diagnostic TEXT with `quick-peek'`."
         (quick-peek-show (concat flymake-diagnostic-at-point-error-prefix text)))
       :custom
       (flymake-diagnostic-at-point-error-prefix nil))
     #+END_SRC

** Version control
   #+BEGIN_SRC emacs-lisp
   (setq vc-follow-symlinks t
         vc-make-backup-files nil)
   #+END_SRC

*** ediff
    - Split horizontally
    - Use existing frame instead of creating a new one
    - Add a third resolution option, copy both A and B to C
    #+BEGIN_SRC emacs-lisp
    (use-package ediff
      :hook
      (ediff-quit . winner-undo)
      (ediff-keymap-setup . +ediff-keys-setup)
      :custom
      (ediff-diff-options "-w")
      (ediff-merge-split-window-function #'split-window-horizontally)
      (ediff-split-window-function #'split-window-horizontally)
      (ediff-window-setup-function #'ediff-setup-windows-plain)
      :preface
      (defun ediff-copy-both-to-C ()
        "Copy change from both A and B to C."
        (interactive)
        (ediff-copy-diff
         ediff-current-difference nil 'C nil
         (concat
          (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
          (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))

      (defun +ediff-keys-setup ()
        "Setup keybindings for `ediff-mode'."
        (general-define-key
         :keymaps 'ediff-mode-map
         "d" '(ediff-copy-both-to-C      :wk "Copy both to C")
         "j" '(ediff-next-difference     :wk "Next difference")
         "k" '(ediff-previous-difference :wk "Previous difference"))))
    #+END_SRC

*** diff-hl
    Diff indicators in fringe
    #+BEGIN_SRC emacs-lisp
    (use-package diff-hl
      :defer 2
      :hook
      (dired-mode         . diff-hl-dired-mode)
      (magit-post-refresh . diff-hl-magit-post-refresh)
      :init
      (autoload 'diff-hl-flydiff-mode "diff-hl-flydiff" nil t)
      (autoload 'diff-hl-dired-mode "diff-hl-dired" nil t)
      :config
      (global-diff-hl-mode 1)
      (diff-hl-flydiff-mode 1))
    #+END_SRC

*** magit
    Enhanced git related views and commands.
    #+BEGIN_SRC emacs-lisp
    (use-package magit
      :defer 2
      :hook
      (git-commit-mode . +git-commit-set-fill-column)
      :custom
      (magit-log-buffer-file-locked t)
      (magit-refs-show-commit-count 'all)
      (magit-save-repository-buffers 'dontask)
      (git-messenger:use-magit-popup t)
      :preface
      (defun +git-commit-set-fill-column ()
        "Set `fill-column' for git commit."
        (setq fill-column 72))
      :config
      ;; Unset pager as it is not supported properly inside emacs.
      (setenv "GIT_PAGER" "")
      (global-magit-file-mode 1))
    #+END_SRC

*** git-messenger
    Popup commit message for current line
    #+BEGIN_SRC emacs-lisp
    (use-package git-messenger
      :general
      ("C-x v p" 'git-messenger:popup-message))
    #+END_SRC

** Packages
*** direnv
    Project-specific environment variables via =direnv=.
    #+BEGIN_SRC emacs-lisp
    (use-package direnv
      :demand t
      :hook
      (before-hack-local-variables . direnv-update-environment)
      :custom
      (direnv-always-show-summary nil)
      :config
      (direnv-mode 1))
    #+END_SRC

*** editorconfig
    Use [[https://editorconfig.org/][EditorConfig]] to maintain the coding styles used across different projects.
    #+BEGIN_SRC emacs-lisp
    (use-package editorconfig
      :defer 1
      :diminish editorconfig-mode
      :custom
      (editorconfig-trim-whitespaces-mode 'ws-butler-mode)
      :config
      (editorconfig-mode 1))
    #+END_SRC

*** eglot
    Generic Language Server Protocol integration via =eglot=.
    #+BEGIN_SRC emacs-lisp
    (use-package eglot
      :defer 3
      :hook
      ((haskell-mode
        java-mode
        ruby-mode
        rustic-mode
        typescript-mode) . eglot-ensure)
      (js-mode . +eglot-ensure-unless-json-mode)
      :preface
      (defun +eglot-ensure-unless-json-mode ()
        (unless (derived-mode-p 'json-mode) (eglot-ensure)))
      :custom
      (eglot-sync-connect nil)
      :general
      (:keymaps
       'eglot-mode-map
       "M-g k" 'eglot-help-at-point)
      (:keymaps
       'eglot-mode-map
       :prefix +local-leader-key
       "e" '(:ignore t :wk "eglot")
       "ea" 'eglot-code-actions
       "ef" 'eglot-format
       "eh" 'eglot-help-at-point
       "er" 'eglot-rename)
      :config
      (cl-pushnew '(typescript-mode . ("javascript-typescript-stdio"))
                  eglot-server-programs
                  :test #'equal))
    #+END_SRC

*** helm-make
    Execute make tasks.
    #+BEGIN_SRC emacs-lisp
    (use-package helm-make
      :custom
      (helm-make-completion-method 'ivy)
      :general
      (:prefix
       +leader-key
       "m" (general-predicate-dispatch #'helm-make
             :docstring "Run make task (project aware)"
             (projectile-project-p) #'helm-make-projectile)))
    #+END_SRC

*** hl-todo
    Highlight *TODO* inside comments and strings.
    #+BEGIN_SRC emacs-lisp
    (use-package hl-todo
      :hook (prog-mode . hl-todo-mode))
    #+END_SRC

*** idle-highlight
    Highlight symbol at point on idle.
    #+BEGIN_SRC emacs-lisp
    (use-package idle-highlight-mode
      :hook
      prog-mode)
    #+END_SRC

*** imenu-list
    Document locations in a sidebar.
    #+BEGIN_SRC emacs-lisp
    (use-package imenu-list
      :general
      (:prefix
       +leader-key
       "i" 'imenu-list-smart-toggle))
    #+END_SRC

*** source-peek
    Peek definition (Display the function source inline).
    #+BEGIN_SRC emacs-lisp
    (use-package source-peek
      :general
      (:prefix
       +nav-prefix
       "SPC" 'source-peek))
    #+END_SRC

*** ws-butler
    Delete trailing white-space before save, but *only* for edited lines.
    #+BEGIN_SRC emacs-lisp
    (use-package ws-butler
      :diminish ws-butler-mode
      :custom
      (ws-butler-convert-leading-tabs-or-spaces t))
    #+END_SRC

** Appearance
*** Highlight delimiters
    Visually separate delimiter pairs.
    #+BEGIN_SRC emacs-lisp
    (use-package rainbow-delimiters
      :custom
      (rainbow-delimiters-max-face-count 3)
      :hook
      ((clojure-mode
        emacs-lisp-mode
        ielm-mode
        lisp-mode
        racket-mode) . rainbow-delimiters-mode))
    #+END_SRC

*** Highlight identifiers
    Highlight source code identifiers based on their name.
    #+BEGIN_SRC emacs-lisp
    (use-package color-identifiers-mode
      :defer 2
      :diminish color-identifiers-mode
      :config
      (cl-pushnew '(js-mode . ("[^.][[:space:]]*"
                                "\\_<\\([a-zA-Z_$]\\(?:\\s_\\|\\sw\\)*\\)"
                                (nil font-lock-variable-name-face js2-function-param)
                                "[a-zA-Z_$]+[(:]"))
                  color-identifiers:modes-alist
                  :test #'equal)
      (cl-pushnew '(rjsx-mode . ("[^.][[:space:]]*"
                                "\\_<\\([a-zA-Z_$]\\(?:\\s_\\|\\sw\\)*\\)"
                                (nil font-lock-variable-name-face js2-function-param)
                                "[a-zA-Z_$]+[(:]"))
                  color-identifiers:modes-alist
                  :test #'equal)
      (cl-pushnew '(typescript-mode . ("[^.][[:space:]]*"
                                       "\\_<\\([a-zA-Z_$]\\(?:\\s_\\|\\sw\\)*\\)"
                                       (nil font-lock-variable-name-face)
                                       "[a-zA-Z_$]+[(:]"))
                  color-identifiers:modes-alist
                  :test #'equal)
      (global-color-identifiers-mode 1))

    (use-package rainbow-identifiers
      :diminish rainbow-identifiers-mode
      :custom
      (rainbow-identifiers-choose-face-function 'rainbow-identifiers-cie-l*a*b*-choose-face))
    #+END_SRC

*** Highlight numbers
    For modes that don't adequately highlight numbers.
    #+BEGIN_SRC emacs-lisp
    (use-package highlight-numbers
      :hook
      (prog-mode . highlight-numbers-mode))
    #+END_SRC

*** Prettify symbols
    #+BEGIN_SRC emacs-lisp
    (custom-set-variables
     '(prettify-symbols-unprettify-at-point t))

    (defun +prog-prettify-symbols-setup ()
      "Add generic programming symbols."
      (dolist (symbol '(("&&" . (?\s (Br . Bl) ?\s (Bc . Bc) ?∧))
                        ("||" . (?\s (Br . Bl) ?\s (Bc . Bc) ?∨))
                        (":=" . (?: (Br . Bc) ?= (Br . Bc) ?=))
                        ("==" . (?≡ (Br . Bc) ?≡ (Br . Bc) ?≡))
                        ("===" . (?≡ (Br . Bc) ?≡ (Br . Bc) ?≡))
                        ("!==" . (?≡ (Br . Bc) ?≢ (Br . Bc) ?≡))
                        (">="  . (?\s (Br . Bl) ?\s (Bc . Bc) ?≥))
                        ("<="  . (?\s (Br . Bl) ?\s (Bc . Bc) ?≤))
                        ("/=" . (?≡ (Br . Bc) ?≢ (Br . Bc) ?≡))
                        ("!=" . (?≡ (Br . Bc) ?≢ (Br . Bc) ?≡))
                        ("<-" . (?< (Br . Bc) ?- (Br . Bc) ?-))
                        ("->" . (?- (Br . Bc) ?- (Br . Bc) ?>))
                        ("<==" . (?< (Br . Bc) ?= (Br . Bc) ?=))
                        ("==>" . (?= (Br . Bc) ?= (Br . Bc) ?>))
                        ("lambda" . ?λ)))
        (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
    (add-hook 'prog-mode-hook #'+prog-prettify-symbols-setup)

    (global-prettify-symbols-mode 1)
    #+END_SRC

* Major modes
** elisp
   #+BEGIN_SRC emacs-lisp
   (add-hook 'emacs-lisp-mode-hook #'flymake-mode)

   (general-define-key
    :keymaps 'emacs-lisp-mode-map
    :prefix +local-leader-key
    "c" 'emacs-lisp-byte-compile
    "C" 'emacs-lisp-byte-compile-and-load
    "t" 'ert)

   (custom-set-variables
    '(ad-redefinition-action 'accept)
    '(apropos-do-all t)
    '(enable-local-eval 'maybe)
    '(enable-local-variables :safe))
   #+END_SRC

   Specific safe local code can be specified via:
   - =safe-local-variable-values=
   - =safe-local-eval-forms=
   - =safe-local-eval-function=

*** ielm
    Persist ielm history.
    #+BEGIN_SRC emacs-lisp
    (defvar +ielm-comint-input-ring nil)
    (with-eval-after-load 'savehist
      (cl-pushnew '+ielm-comint-input-ring savehist-additional-variables :test #'equal))

    (defun +ielm-set-comint-input-ring ()
      "Restore `ielm' history."
      (setq-local comint-input-ring-size 200)
      (add-hook 'kill-buffer-hook #'+ielm-save-comint-input-ring nil t)
      (when +ielm-comint-input-ring
        (setq comint-input-ring +ielm-comint-input-ring)))

    (defun +ielm-save-comint-input-ring ()
      "Save `ielm' history."
      (setq +ielm-comint-input-ring comint-input-ring))

    (add-hook 'ielm-mode-hook #'+ielm-set-comint-input-ring)
    #+END_SRC

*** eval-expression
    Highlight parenthesis.
    #+BEGIN_SRC emacs-lisp
    (add-hook 'eval-expression-minibuffer-setup-hook #'show-paren-mode)
    #+END_SRC

*** Packages
**** auto-compile
     Auto-compile Elisp files.
     #+BEGIN_SRC emacs-lisp
     (use-package auto-compile
       :hook
       (emacs-lisp-mode . auto-compile-on-load-mode)
       (emacs-lisp-mode . auto-compile-on-save-mode)
       :custom
       (auto-compile-display-buffer nil)
       (auto-compile-use-mode-line nil))
     #+END_SRC

**** eros
     Evaluation results in overlay.
     #+BEGIN_SRC emacs-lisp
     (use-package eros
       :hook
       (emacs-lisp-mode . eros-mode))
     #+END_SRC

**** esup
     Emacs Start Up Profiler.
     #+BEGIN_SRC emacs-lisp
     (use-package esup)
     #+END_SRC

**** helpful
     Better =*help*= buffer
     #+BEGIN_SRC emacs-lisp
     (use-package helpful
       :hook
       (helpful-mode . turn-off-truncate-lines)
       :general
       (:keymaps
        'emacs-lisp-mode-map
        :prefix +nav-prefix
        "h" 'helpful-at-point)
       (:keymaps
        'help-map
        "C" 'helpful-command
        "f" 'helpful-function
        "F" 'helpful-callable
        "k" 'helpful-key
        "M" 'helpful-macro
        "v" 'helpful-variable)
       (:keymaps
        'helpful-mode-map
        "[[" 'backward-button
        "]]" 'forward-button))
     #+END_SRC

**** highlight-quoted
     #+BEGIN_SRC emacs-lisp
     (use-package highlight-quoted
       :hook
       (emacs-lisp-mode . highlight-quoted-mode))
     #+END_SRC

**** package-lint-flymake
     #+BEGIN_SRC emacs-lisp
     (use-package package-lint-flymake
       :hook
       (emacs-lisp-mode . package-lint-setup-flymake))
     #+END_SRC

**** suggest
     Discover functions.
     #+BEGIN_SRC emacs-lisp
     (use-package suggest
       :general
       (:keymaps
        'emacs-lisp-mode-map
        :prefix +local-leader-key
        "s" '+suggest-popup)
       :preface
       (defun +suggest-popup ()
         "Open suggest as a popup."
         (interactive)
         (let* ((window         (selected-window))
                (dedicated-flag (window-dedicated-p window)))
           (set-window-dedicated-p window t)
           (suggest)
           (set-window-dedicated-p window dedicated-flag))))
     #+END_SRC

*** Appearance
**** Package prefixes
     Shorten package prefixes.
     #+BEGIN_SRC emacs-lisp
     (use-package nameless
       :diminish nameless-mode
       :hook
       (emacs-lisp-mode . nameless-mode))
     #+END_SRC

**** Prettify symbols
     #+BEGIN_SRC emacs-lisp
     (defun +emacs-lisp-prettify-symbols-setup ()
       "Prettify `emacs-lisp-mode' specific symbols."
       (dolist (symbol '(("defun"    . ?ƒ)
                         ("defmacro" . ?μ)
                         ("defvar"   . ?ν)
                         ("defconst" . "ν_")))
         (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
     (add-hook 'emacs-lisp-mode-hook #'+emacs-lisp-prettify-symbols-setup)
     #+END_SRC

**** Regular expression escapes
     Improve readability of escape characters in regular expressions.
     #+BEGIN_SRC emacs-lisp
     (use-package easy-escape
       :diminish easy-escape-minor-mode
       :hook
       (emacs-lisp-mode . easy-escape-minor-mode))
     #+END_SRC

** erc
   #+BEGIN_SRC emacs-lisp
   (use-package erc
     :hook
     (erc-mode . +erc-line-setup)
     (erc-mode . +erc-parens-setup)
     :custom
     (erc-hide-list '("JOIN" "PART" "QUIT"))
     (erc-prompt-for-password nil)
     :preface
     (defun +erc-line-setup ()
       "Line configuration for `erc-mode'."
       (visual-line-mode 0)
       (turn-off-truncate-lines))

     (defun +erc-parens-setup ()
       "Parenthesis configuration for `erc-mode'."
       (smartparens-strict-mode 0)
       (smartparens-mode 1)))
   #+END_SRC

** eshell
   #+BEGIN_SRC emacs-lisp
   (use-package eshell
     :hook
     (eshell-mode . abbrev-mode)
     (eshell-mode . +eshell-define-keys)
     (eshell-mode . +eshell-set-visual-commands)
     :custom
     (eshell-buffer-maximum-lines 20000)
     (eshell-history-size 1000)
     (eshell-hist-ignoredups t)
     (eshell-error-if-no-glob t)
     (eshell-destroy-buffer-when-process-dies t)
     :general
     (:prefix
      +launch-prefix
      "t" 'eshell)
     :preface
     (defvar eshell-visual-commands)
     (defun +eshell-define-keys ()
       (general-define-key
        :keymaps 'eshell-mode-map
        "RET" '+eshell-expand-abbrev-and-send-input
        "<tab>" 'completion-at-point
        "C-r" 'counsel-esh-history))

     (defun +eshell-set-visual-commands ()
       (setq eshell-visual-commands
             (append
              '("fish" "ghcid" "jshell" "most" "ssh" "tail" "tsun" "watch")
              eshell-visual-commands)))
     :init
     (autoload 'eshell-smart-initialize "em-smart"))
   #+END_SRC

*** Abbreviations
    Fish-like abbreviations that expand on space or enter.
    #+BEGIN_SRC emacs-lisp
    (defun +eshell-expand-abbrev-and-send-input ()
      "Expand abbreviation and send input to `eshell'."
      (interactive)
      (expand-abbrev)
      (call-interactively #'eshell-send-input))

    (defun +eshell-abbrev-expand-p ()
      "Return t if abbreviation should be expanded.
    Expansion should happen when abbreviation is at the beginning of
    the line or after an eshell operator."
      (let* ((end (point-marker))
             (begin (save-excursion (eshell-bol) (point)))
             (args (catch 'eshell-incomplete (eshell-parse-arguments begin end))))
        (or (= 1 (length args))
            (let ((last-two-args (last args 2)))
              (and (consp (car last-two-args))
                   (eq (caar last-two-args)
                       'eshell-operator))))))

    (define-abbrev-table 'eshell-mode-abbrev-table
      '(("base64" "base64 -w0")
        ("d" "docker")
        ("dim" "docker images")
        ("dp" "docker ps")
        ("dc" "docker-compose")
        ("dcl" "docker-compose logs")
        ("e" "find-file-other-window")
        ("E" "dired")
        ("gd" "magit-diff-unstaged")
        ("gds" "magit-diff-staged")
        ("gs" "magit-status")
        ("time" "time -p")
        ("tree" "tree -a")
        ("week" "date '+%V'"))
      :enable-function #'+eshell-abbrev-expand-p)
    #+END_SRC

*** Packages
**** eshell-fringe-status
     Command execution status indicator in the fringe.
     #+BEGIN_SRC emacs-lisp
     (use-package eshell-fringe-status
       :hook
       (eshell-mode . eshell-fringe-status-mode))
     #+END_SRC

**** esh-autosuggest
     Autosuggestions from history similar to fish.
     #+BEGIN_SRC emacs-lisp
     (use-package esh-autosuggest
       :hook
       (eshell-mode . esh-autosuggest-mode)
       :general
       (:keymaps
        'esh-autosuggest-active-map
        "C-e" 'company-complete-selection))
     #+END_SRC

**** fish-completion
     Populate auto-completions from fish.
     #+BEGIN_SRC emacs-lisp
     (use-package fish-completion
       :hook
       (eshell-mode . fish-completion-mode))
     #+END_SRC

** org
   #+BEGIN_SRC emacs-lisp
     (use-package org-plus-contrib
       :hook
       (org-mode . auto-fill-mode)
       (org-mode . hide-mode-line-mode)
       (org-mode . +org-cursor-setup)
       (org-babel-after-execute . org-redisplay-inline-images)
       ;; :minor
       ;; ("init\\.org$" . auto-tangle-mode)
       :custom
       (org-agenda-files '("~/org"))
       (org-confirm-babel-evaluate nil)
       (org-babel-load-languages
	'((emacs-lisp . t)
	  (clojure    . t)
	  (js         . t)
	  (plantuml   . t)
	  (shell      . t)))
       (org-edit-src-content-indentation 0)
       (org-ellipsis "  ")
       (org-fontify-whole-heading-line t)
       (org-fontify-done-headline t)
       (org-fontify-quote-and-verse-blocks t)
       (org-hide-emphasis-markers t)
       (org-image-actual-width 800)
       (org-log-done 'time)
       (org-plantuml-jar-path "~/.local/lib/plantuml.jar")
       (org-pretty-entities t)
       (org-startup-folded nil)
       (org-startup-with-inline-images t)
       (org-special-ctrl-a/e t)
       (org-src-preserve-indentation nil)
       (org-src-fontify-natively t)
       (org-src-tab-acts-natively t)
       (org-src-window-setup 'current-window)
       (org-tag-alist
	'(("@work"  . ?w)
	  ("@home"  . ?h)
	  ("laptop" . ?l)))
       :defines org-babel-load-languages
       :general
       (:keymaps
	'org-mode-map
	"C-'" 'nil
	"C-," 'nil)
       :preface
       (defun +org-cursor-setup ()
	 "Setup bar cursor for `org-mode'."
	 (setq cursor-type 'bar))
       :config
       (org-babel-do-load-languages
	'org-babel-load-languages
	org-babel-load-languages))
   #+END_SRC

*** Packages
**** org-cliplink
     Paste links from clipboard and automatically fetch title.
     #+BEGIN_SRC emacs-lisp
     (use-package org-cliplink
       :general
       (:keymaps
        'org-mode-map
        :prefix +local-leader-key
        "l" 'org-cliplink))
     #+END_SRC

**** org-noter
     Annotate documents with =org-mode=.
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package org-noter)
     #+END_SRC

**** org-preview-html
     Preview org-file in an =eww= buffer.
     #+BEGIN_SRC emacs-lisp
     (use-package org-preview-html)
     #+END_SRC

**** org-radiobutton
     Support for radiobuttons.
     #+BEGIN_SRC emacs-lisp
     (use-package org-radiobutton
       :hook
       (org-mode . org-radiobutton-mode))
     #+END_SRC

**** org-tree-slide
     Presentation mode.
     #+BEGIN_SRC emacs-lisp
     (use-package org-tree-slide
       :custom
       (org-tree-slide-header nil)
       (org-tree-slide-slide-in-effect nil)
       :general
       (:keymaps
        'org-mode-map
        :prefix +local-leader-key
        "p" 'org-tree-slide-mode))
     #+END_SRC

**** ob-http
     #+BEGIN_SRC emacs-lisp
     (use-package ob-http
       :init
       (cl-pushnew '(http . t) org-babel-load-languages :test #'equal))
     #+END_SRC

*** Appearance
    This sections makes =org-mode= look more beautiful and appealing.

**** Variable pitch
     Use variable-pitch font but still make sure everything aligns.
     #+BEGIN_SRC emacs-lisp
     (use-package org-variable-pitch
       :diminish org-variable-pitch-minor-mode
       :hook
       (org-mode . org-variable-pitch-minor-mode)
       :custom
       (org-variable-pitch-fixed-font +fixed-pitch-font)
       :init
       ;; Also align headings and lists
       (font-lock-add-keywords
        'org-mode
        '(("^[[:space:]-*+]+" 0 'org-variable-pitch-face append))
        'append))
     #+END_SRC

**** Heading bullets
     #+BEGIN_SRC emacs-lisp
     (use-package org-bullets
       :hook
       (org-mode . org-bullets-mode)
       :custom
       (org-bullets-bullet-list '(" "))
       ;; Use default font face (also size)
       (org-bullets-face-name 'org-variable-pitch-face))
     #+END_SRC

**** Bullet lists
     #+BEGIN_SRC emacs-lisp
     (font-lock-add-keywords
      'org-mode
      '(("^ +\\([-*+]\\) "
         (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "●"))))
        ("^ *[-*+] \\[\\(X\\)\\] "
         (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "✕"))))))
     #+END_SRC

**** Task lists
     #+BEGIN_SRC emacs-lisp
     (defun +org-prettify-task-symbols-setup ()
       "Prettify task list symbols."
       (dolist (symbol '(("TODO"     . ?⚑)
                         ("DOING"    . ?⚐)
                         ("CANCELED" . ?✘)
                         ("DONE"     . ?✔)))
         (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
     (add-hook 'org-mode-hook #'+org-prettify-task-symbols-setup)
     #+END_SRC

**** Breadcrumbs
     Remove style from heading breadcrumbs.
     #+BEGIN_SRC emacs-lisp
     (defun +org-eldoc-get-breadcrumb-no-properties (string)
       "Remove properties from STRING."
       (when string
         (substring-no-properties string)))
     (advice-add 'org-eldoc-get-breadcrumb :filter-return #'+org-eldoc-get-breadcrumb-no-properties)
     #+END_SRC

**** Tables
     #+BEGIN_SRC emacs-lisp
     (use-package org-pretty-table
       :hook
       (org-mode . org-pretty-table-mode))
     #+END_SRC

** ansible
   #+BEGIN_SRC emacs-lisp
     ;; (use-package ansible
     ;;   :minor
     ;;   "site\\.yml$"
     ;;   "roles/.+\\.yml$"
     ;;   :magic-minor
     ;;   "^\\(---\n\\)?\\(#.*\n\\)* *-? \\(environment\\|h\\(?:\\(?:andler\\|ost\\)s\\)\\|i\\(?:mport_tasks\\|nclude\\(?:_tasks\\)?\\)\\|p\\(?:\\(?:ost\\|re\\)_tasks\\)\\|roles?\\|tasks\\|vars\\(?:_\\(?:files\\|prompt\\)\\)?\\):")

     ;; (use-package ansible-doc
     ;;   :diminish ansible-doc-mode
     ;;   ;; :hook (ansible . ansible-doc-mode)
     ;;   :preface
     ;;   (defun ansible-doc-at-point ()
     ;;     "Ansible doc with selected point"
     ;;     (interactive)
     ;;     (ansible-doc (thing-at-point 'symbol)))
     ;;   :general
     ;;   (:keymaps
     ;;    'ansible::key-map
     ;;    "M-g k" 'ansible-doc-at-point))
   #+END_SRC

** clojure
   #+BEGIN_SRC emacs-lisp
   (use-package clojure-mode)
   #+END_SRC

*** Packages
**** cider
     #+BEGIN_SRC emacs-lisp
     (use-package cider
       :hook
       (cider-mode . cider-auto-test-mode)
       :custom
       (cider-prompt-for-symbol nil)
       (cider-repl-display-help-banner nil)
       (cider-repl-history-file (concat +data-dir "cider-history"))
       (org-babel-clojure-backend 'cider)
       :general
       (:keymaps
        'cider-mode-map
        :prefix +local-leader-key
        "c" 'cider-refresh
        "t" 'cider-test-run-test
        "T" 'cider-test-run-ns-tests
        "s" 'cider-test-run-project-tests))
     #+END_SRC

** crystal
   #+BEGIN_SRC emacs-lisp
   (use-package crystal-mode
     :general
     (:keymaps
      'crystal-mode-map
      :prefix +local-leader-key
      "t" 'crystal-spec-line
      "T" 'crystal-spec-buffer
      "s" 'crystal-spec-all))
   #+END_SRC

*** Packages
**** inf-crystal
     #+BEGIN_SRC emacs-lisp
     (use-package inf-crystal
       :hook
       (crystal-mode . inf-crystal-minor-mode)
       :general
       (:keymaps
        'crystal-mode-map
        :prefix +local-leader-key
        "r" 'inf-crystal))
     #+END_SRC

** csv
   #+BEGIN_SRC emacs-lisp
   (use-package csv-mode
     :custom
     (csv-separators '("," "\t" ";")))
   #+END_SRC

** elasticsearch
   #+BEGIN_SRC emacs-lisp
   (use-package es-mode)
   #+END_SRC

** elixir
   #+BEGIN_SRC emacs-lisp
   (use-package elixir-mode)
   #+END_SRC

*** Packages
**** alchemist
     #+BEGIN_SRC emacs-lisp
     (use-package alchemist
       :hook
       (elixir-mode . alchemist-mode)
       :general
       (:keymaps
        'alchemist-mode-map
        "M-g k" 'alchemist-help-search-at-point)
       (:keymaps
        'alchemist-mode-map
        :prefix +local-leader-key
        "r" 'alchemist-iex-run
        "s" 'alchemist-mix-test
        "t" 'alchemist-mix-test-at-point
        "T" 'alchemist-mix-test-this-buffer))
     #+END_SRC

** elm
   #+BEGIN_SRC emacs-lisp
   (use-package elm-mode
     :custom
     (elm-format-on-save t)
     (elm-package-json "elm.json")
     (elm-tags-exclude-elm-stuff nil)
     (elm-tags-on-save t)
     :general
     (:keymaps
      'elm-mode-map
      :prefix +local-leader-key
      "t" 'elm-test-project))
   #+END_SRC

** epub
*** Packages
**** nov
     #+BEGIN_SRC emacs-lisp
     (use-package nov
       :mode
       ("\\.epub$" . nov-mode)
       :hook
       (nov-mode . +nov-delayed-render-setup)
       (nov-mode . +nov-fringes-setup)
       :custom
       (nov-save-place-file (concat +data-dir "nov-places"))
       :preface
       (defun +nov-delayed-render-setup ()
         (run-with-idle-timer 0.2 nil 'nov-render-document))

       (defun +nov-fringes-setup ()
         "Hide the fringes for `nov-mode'."
         (set-window-fringes (get-buffer-window) 0 0 nil)))
     #+END_SRC

** erlang
   #+BEGIN_SRC emacs-lisp
   (use-package erlang
     :hook
     (erlang-mode . +erlang-eunit-setup)
     (erlang-mode . +erlang-flymake-setup)
     :general
     (:keymaps
      'erlang-mode-map
      "M-g k" 'erlang-man-function)
     (:keymaps
      'erlang-mode-map
      :prefix +local-leader-key
      "t" 'erlang-eunit-compile-and-run-current-test
      "T" 'erlang-eunit-compile-and-run-module-tests
      "r" 'erlang-shell-display)
     :preface
     (defun +erlang-eunit-setup ()
       "Setup EUnit support for `erlang-mode'."
       (require 'erlang-eunit))
     (defun +erlang-flymake-setup ()
       "Setup `flymake' support for `erlang-mode'."
       (require 'erlang-flymake)
       (flymake-mode 1)))
   #+END_SRC

*** Packages
**** ivy-erlang-complete
     #+BEGIN_SRC emacs-lisp
     (use-package ivy-erlang-complete
       :hook
       (erlang-mode . ivy-erlang-complete-init)
       (erlang-mode . +erlang-ivy-completion-setup)
       :preface
       (defun +erlang-ivy-completion-setup ()
         "Setup completion via `ivy' for `erlang-mode'."
         (add-hook 'after-save-hook #'ivy-erlang-complete-reparse nil t)))
     #+END_SRC

** git
*** Packages
**** gitignore-mode
     #+BEGIN_SRC emacs-lisp
     (use-package gitignore-mode
       :mode
       ("/\\.dockerignore$" . gitignore-mode))
     #+END_SRC

** go
   #+BEGIN_SRC emacs-lisp
   (use-package go-mode
     :hook
     (go-mode . +go-prettify-symbols-setup)
     :custom
     (gofmt-command "goimports")
     :general
     (:keymaps
      'go-mode-map
      "M-g k" 'godoc-at-point)
     :preface
     (defun +go-prettify-symbols-setup ()
       (dolist (symbol '(("funct"  . ?ƒ)))
         (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
   #+END_SRC

*** Packages
**** go-eldoc
     #+BEGIN_SRC emacs-lisp
     (use-package go-eldoc
       :hook
       (go-mode . go-eldoc-setup))
     #+END_SRC

**** gorepl-mode
     #+BEGIN_SRC emacs-lisp
     (use-package gorepl-mode
       :hook
       (go-mode . gorepl-mode))
     #+END_SRC

** groovy
   #+BEGIN_SRC emacs-lisp
   (use-package groovy-mode)
   #+END_SRC

** fish
   #+BEGIN_SRC emacs-lisp
   (use-package fish-mode)
   #+END_SRC

** haskell
   #+BEGIN_SRC emacs-lisp
   (use-package haskell-mode
     :hook
     (haskell-mode . interactive-haskell-mode)
     :custom
     (haskell-font-lock-symbols t)
     (haskell-process-auto-import-loaded-modules t)
     (haskell-process-log t)
     (haskell-process-show-debug-tips nil)
     (haskell-process-use-presentation-mode t)
     (haskell-stylish-on-save t)
     (haskell-mode-stylish-haskell-path "brittany")
     :general
     (:keymaps
      'interactive-haskell-mode-map
      "M-." 'nil)
     (:keymaps
      'haskell-mode-map
      :prefix +local-leader-key
      "r" 'haskell-interactive-switch
      "R" 'haskell-session-change-target)
     :init
     ;; Allow configuring project local cabal repl commands.
     (put 'haskell-process-args-cabal-repl 'safe-local-variable (lambda (x) (seq-every-p #'stringp x))))
   #+END_SRC

*** REPL
    Persist REPL history.
    #+BEGIN_SRC emacs-lisp
    (defvar +haskell-interactive-global-history nil)
    (with-eval-after-load 'savehist
      (cl-pushnew '+haskell-interactive-global-history savehist-additional-variables :test #'equal))

    (defun +haskell-interactive-load-history ()
      "Restore `haskell-interactive-mode' history."
      (add-hook 'kill-buffer-hook #'+haskell-interactive-save-history nil t)
      (when +haskell-interactive-global-history
        (setq haskell-interactive-mode-history +haskell-interactive-global-history)))

    (defun +haskell-interactive-save-history ()
      "Save `haskell-interactive-mode' history."
      (setq +haskell-interactive-global-history haskell-interactive-mode-history))

    (add-hook 'haskell-interactive-mode-hook #'+haskell-interactive-load-history)
    #+END_SRC

*** Packages
**** hasky-stack
     #+BEGIN_SRC emacs-lisp
     (use-package hasky-stack
       :general
       (:keymaps
        'haskell-mode-map
        :prefix +local-leader-key
        "t" 'hasky-stack-test))
     #+END_SRC

** java
*** Packages
**** gradle-mode
     #+BEGIN_SRC emacs-lisp
     (use-package gradle-mode
       :hook ((java-mode kotlin-mode) . gradle-mode)
       :general
       (:keymaps
        'gradle-mode-map
        :prefix +local-leader-key
        "t" 'gradle-test))
     #+END_SRC

**** java-lookup
     #+BEGIN_SRC emacs-lisp
     (use-package javadoc-lookup
       :general
       (:keymaps
        'java-mode-map
        "M-g k" 'javadoc-lookup))
     #+END_SRC

** js
   #+BEGIN_SRC emacs-lisp
   (use-package js-mode
     :hook
     (js-mode . +js-find-file-setup)
     (js-mode . +js-prettify-symbols-setup)
     :preface
     (defun +js-find-file-setup ()
       "Setup `ff-test-find-other-file' support for `js-mode'."
       (setq ff-test-search-implementation-project-directories '("src")
             ff-test-search-test-directories '("." "__tests__")
             ff-test-search-test-project-directories '("test" "spec" "__tests__")))

     (defun +js-prettify-symbols-setup ()
       (dolist (symbol '(("=="        . ?≈)
                         ("!="        . "≈/")
                         ("=>"        . (?- (Br . Bc) ?- (Br . Bc) ?>))
                         ("function"  . ?ƒ)
                         ("let"       . ?ν)
                         ("const"     . "ν_")
                         ("undefined" . ?∅)
                         ("Infinity"  . ?∞)))
         (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
   #+END_SRC

*** Packages
**** flymake-eslint
     #+BEGIN_SRC emacs-lisp
     (use-package flymake-eslint
       :init
       (cl-pushnew '(flymake-eslint-enable) safe-local-eval-forms :test #'equal)
       (put 'flymake-eslint-executable-name 'safe-local-variable #'(lambda (x) (member x '("eslint" "eslint_d"))))
       (put 'flymake-eslint-executable-args 'safe-local-variable 'stringp))
     #+END_SRC

**** indium
     Debugger
     #+BEGIN_SRC emacs-lisp
     (use-package indium
       :diminish indium-interaction-mode
       :hook
       (js-mode . +indium-interaction-unless-json-mode)
       :preface
       (defun +indium-interaction-unless-json-mode ()
         (unless (derived-mode-p 'json-mode) (indium-interaction-mode)))
       :general
       (:keymaps
        'js-mode-map
        :prefix +local-leader-key
        "s" 'indium-scratch
        "o" 'indium-launch
        "O" 'indium-connect)
       (:keymaps
        'indium-debugger-mode
        :definer 'minor-mode
        "RET" 'indium-debugger-step-over))
     #+END_SRC

**** jest
     Test framework execution.
     #+BEGIN_SRC emacs-lisp
     (use-package jest
       :general
       (:keymaps
        'js-mode-map
        :prefix +local-leader-key
        "t" 'jest-funcion-dwim
        "T" 'jest-file
        "s" 'jest-popup))
     #+END_SRC

**** js2
     #+BEGIN_SRC emacs-lisp
     (use-package js2-mode
       :hook
       (js-mode . js2-minor-mode)
       :custom
       (js2-highlight-external-variables nil)
       (js2-mode-show-parse-errors nil)
       (js2-skip-preprocessor-directives t)
       (js2-strict-missing-semi-warning nil)
       (js2-strict-trailing-comma-warning nil))
     #+END_SRC

**** js2-refactor
     Refactor utils, also a dependecy for =indium= debugger.
     #+BEGIN_SRC emacs-lisp
     (use-package js2-refactor
       :diminish js2-refactor-mode
       :hook
       (js2-minor-mode . js2-refactor-mode)
       (js2-minor-mode . +js2r-setup-keybindings)
       :preface
       (defun +js2r-setup-keybindings ()
         (js2r-add-keybindings-with-prefix (string-join `(,+local-leader-key "m") " "))))
     #+END_SRC

**** nodejs-repl
     REPL for nodejs.
     #+BEGIN_SRC emacs-lisp
     (use-package nodejs-repl)
     #+END_SRC

** json
   #+BEGIN_SRC emacs-lisp
   (use-package json-mode
     :preface
     (defun +json-mode-setup-flymake ()
       "Setup `json-mode' integration with Flymake."
       (add-hook 'flymake-diagnostic-functions #'flymake-check-jsonlint nil t)
       (flymake-mode))
     :hook
     (json-mode . +json-mode-setup-flymake))
   #+END_SRC

*** Syntax checker
    #+BEGIN_SRC emacs-lisp
    (flymake-quickdef-backend flymake-check-jsonlint
      :pre-let ((jsonlint-exec (executable-find "jsonlint")))
      :pre-check (unless jsonlint-exec (error "Cannot find jsonlint executable"))
      :write-type 'file
      :proc-form (list jsonlint-exec "-c" "-q" fmqd-temp-file)
      :search-regexp "^\\(.+\\)\: line \\([0-9]+\\), col \\([0-9]+\\), \\(.+\\)$"
      :prep-diagnostic
      (let* ((lnum (string-to-number (match-string 2)))
             (col (string-to-number (match-string 3)))
             (msg (match-string 4))
             (pos (flymake-diag-region fmqd-source lnum col))
             (beg (car pos))
             (end (cdr pos))
             (type :error))
        (list fmqd-source beg end type msg)))
    #+END_SRC

*** Packages
**** json-navigator
     #+BEGIN_SRC emacs-lisp
     (use-package json-navigator
       :general
       (:keymaps
        'json-mode-map
        :prefix +local-leader-key
        "n" 'json-navigator-navigate-region))
     #+END_SRC

** jsx
   React JSX support.
   #+BEGIN_SRC emacs-lisp
     (use-package rjsx-mode
       :mode
       "\\.jsx$"
       :magic
       ("\\(import.*from \'react\';?\\|\/\/ @flow\nimport.*from \'react\';?\\)" . rjsx-mode)
       :general
       (:keymaps
	'rjsx-mode-map
	:prefix +local-leader-key
	"R" 'rjsx-rename-tag-at-point))
   #+END_SRC

** kotlin
   #+BEGIN_SRC emacs-lisp
   (use-package kotlin-mode)
   #+END_SRC

** lisp
*** Packages
**** slime
     #+BEGIN_SRC emacs-lisp
     (use-package slime
       :hook
       (lisp-mode . slime-mode)
       :custom
       (inferior-lisp-program "sbcl")
       (slime-contribs '(slime-fancy slime-repl))
       :general
       (:keymaps
        'slime-mode-map
        "M-g k" 'slime-describe-symbol)
       (:keymaps
        'slime-mode-map
        :prefix +local-leader-key
        "o" 'slime
        "t" 'slime-load-file-and-other-file)
       :preface
       (defun slime-load-file-and-other-file ()
         "Load buffer file and then load other (test) file."
         (interactive)
         (dolist (file `(,buffer-file-name ,(ff-test-other-file-name)))
           (when (and file (file-exists-p file))
             (slime-load-file file)))))
     #+END_SRC

** lua
   #+BEGIN_SRC emacs-lisp
   (use-package lua-mode
     :hook
     (lua-mode . +lua-prettify-symbols-setup)
     :custom
     (lua-documentation-function 'eww)
     :general
     (:keymaps
      'lua-mode-map
      "M-g k" 'lua-search-documentation)
     :preface
     (defun +lua-prettify-symbols-setup ()
       (dolist (symbol '(("~="  . (?\s (Br . Bl) ?\s (Bc . Bc) ?≠))
                         ("function"  . ?ƒ)
                         ("math.huge" . ?∞)))
         (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
   #+END_SRC

** markdown
   #+BEGIN_SRC emacs-lisp
   (use-package markdown-mode
     :hook
     (markdown-mode . auto-fill-mode)
     :custom
     (markdown-enable-wiki-links t)
     (markdown-fontify-code-blocks-natively t)
     (markdown-header-scaling t)
     (markdown-hide-markup t)
     (markdown-italic-underscore t)
     (markdown-make-gfm-checkboxes-buttons t)
     :general
     (:keymaps
      'markdown-mode-map
      :prefix +local-leader-key
      "v" 'markdown-toggle-markup-hiding))
   #+END_SRC

*** Packages
**** edit-indirect
     Editing regions in separate buffers.
     #+BEGIN_SRC emacs-lisp
     (use-package edit-indirect)
     #+END_SRC

**** markdown-toc
     Generate Table of Contents.
     #+BEGIN_SRC emacs-lisp
     (use-package markdown-toc)
     #+END_SRC

*** Appearance
**** Variable pitch
     Use variable-pitch font but still make sure everything aligns.
     #+BEGIN_SRC emacs-lisp
     (font-lock-add-keywords
      'markdown-mode
      '(("^[[:space:]-*+>]+" 0 'fixed-pitch append))
      'append)
     #+END_SRC

**** Bullet lists
     Pretty check-boxes
     #+BEGIN_SRC emacs-lisp
     (font-lock-add-keywords
      'markdown-mode
      '(("^ *[-*+] \\[\\([Xx]\\)\\] "
         (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "✕"))))))
     #+END_SRC

** nginx
   #+BEGIN_SRC emacs-lisp
   (use-package nginx-mode)
   #+END_SRC

** nix
   #+BEGIN_SRC emacs-lisp
   (use-package nix-mode)
   #+END_SRC

*** Packages
**** nix-update
     #+BEGIN_SRC emacs-lisp
     (use-package nix-update
       :general
       (:keymaps
        'nix-mode-map
        :prefix +local-leader-key
        "u" 'nix-update-fetch))
     #+END_SRC

** nxml
   #+BEGIN_SRC emacs-lisp
   (use-package nxml-mode
     :mode "\\.plist$"
     :custom
     (nxml-slash-auto-complete-flag t)
     :config
     (with-eval-after-load 'smartparens
       (sp-local-pair '(nxml-mode) "<" ">" :actions :rem)))
   #+END_SRC

** ocaml
   #+BEGIN_SRC emacs-lisp
   (use-package caml)

   (use-package tuareg
     :general
     (:keymaps
      'tuareg-mode-map
      "C-x C-e" 'tuareg-eval-phrase)
     (:keymaps
      'tuareg-mode-map
      :prefix +local-leader-key
      "r" 'run-ocaml))
   #+END_SRC

** pdf
*** Packages
**** pdf-tools
     #+BEGIN_SRC emacs-lisp
     (use-package pdf-tools
       :mode ("\\.pdf$" . pdf-view-mode))
     #+END_SRC

** plantuml
   #+BEGIN_SRC emacs-lisp
   (use-package plantuml-mode
     :custom
     (plantuml-default-exec-mode 'executable))
   #+END_SRC

** protobuf
   #+BEGIN_SRC emacs-lisp
   (use-package protobuf-mode)
   #+END_SRC

** python
   #+BEGIN_SRC emacs-lisp
   (use-package python
     :hook
     (python-mode . +python-prettify-symbols-setup)
     :general
     (:keymaps
      'python-mode-map
      :prefix +local-leader-key
      "r" 'run-python)
     :preface
     (defun +python-prettify-symbols-setup ()
       (dolist (symbol '(("def"      . ?ƒ)
                         ("sum"      . ?Σ)
                         ("not"      . ?￢)
                         ("in"       . ?∈)
                         ("for"      . ?∀)
                         ("**2"      . ?²)
                         ("**3"      . ?³)
                         ("None"     . ?∅)
                         ("math.inf" . ?∞)))
         (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
   #+END_SRC

*** Packages
**** pip-requirements
     Editing pip requirements files.
     #+BEGIN_SRC emacs-lisp
     (use-package pip-requirements)
     #+END_SRC

**** pydoc
     #+BEGIN_SRC emacs-lisp
     (use-package pydoc
       :general
       (:keymaps
        'python-mode-map
        "M-g k" 'pydoc-at-point))
     #+END_SRC

**** python-test
     #+BEGIN_SRC emacs-lisp
     (use-package python-test
       :custom
       (python-test-backend 'pytest)
       :general
       (:keymaps
        'python-mode-map
        :prefix +local-leader-key
        "t" 'python-test-project)
       :config
       (setq python-test-project-root-files
             (append '("README.md") python-test-project-root-files)))
     #+END_SRC

** racket
   #+BEGIN_SRC emacs-lisp
   (use-package racket-mode
     :general
     (:keymaps
      'racket-mode-map
      "M-g k" 'racket-doc)
     (:keymaps
      'racket-mode-map
      :prefix +local-leader-key
      "t" 'racket-test))
   #+END_SRC

*** Packages
**** flymake-racket
     #+BEGIN_SRC emacs-lisp
     (use-package flymake-racket
       :hook
       (racket-mode . flymake-racket-add-hook))
     #+END_SRC

** rst
   #+BEGIN_SRC emacs-lisp
   (use-package rst
     :hook
     (rst-mode . auto-fill-mode)
     :preface
     (defvar rst-adornment-regexp nil
       "Regular expression to match adornments.")
     :config
     (setq rst-adornment-regexp
           (concat "^[" rst-adornment-chars "]\\{3,\\}$")))
   #+END_SRC

*** Appearance
**** Variable pitch
     Use variable-pitch font but still make sure everything aligns.
     #+BEGIN_SRC emacs-lisp
     (font-lock-add-keywords
      'rst-mode
      '(("^[[:space:]-*+]+\\(\\[.\\]\\)?" 0 'fixed-pitch append))
      'append)
     #+END_SRC

**** Heading
     Hide heading adornments.
     #+BEGIN_SRC emacs-lisp
     (defun +rst-hide-heading-adornment ()
       "Hide heading adornment for `rst-mode'."
       (interactive)
       (hide-lines-matching rst-adornment-regexp))
     (add-hook 'rst-mode-hook #'+rst-hide-heading-adornment)
     #+END_SRC

**** Bullet lists
     Pretty check-boxes as well as bullet lists.
     #+BEGIN_SRC emacs-lisp
     (font-lock-add-keywords
      'rst-mode
      '(("^ *\\([-*+]\\) "
         (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "●"))))
        ("^ *[-*+] \\[\\([Xx]\\)\\] "
         (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "✕"))))))
     #+END_SRC

** ruby
   #+BEGIN_SRC emacs-lisp
   (use-package ruby-mode
     :hook
     (ruby-mode . +ruby-find-file-setup)
     (ruby-mode . +ruby-prettify-symbols-setup)
     :custom
     (ruby-align-chained-calls t)
     :preface
     (defun +ruby-find-file-setup ()
       "Setup `ff-test-find-other-file' support for `ruby-mode'."
       (setq ff-test-suffixes '("_test" "_spec")
             ff-test-search-implementation-project-directories '("app" "lib")
             ff-test-search-test-project-directories '("test" "spec")))

     (defun +ruby-prettify-symbols-setup ()
       (dolist (symbol '(("def"             . ?ƒ)
                         ("Float::INFINITY" . ?∞)))
         (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
     :config
     (with-eval-after-load 'hideshow
       (cl-pushnew `(ruby-mode
                     ,(rx (or "def" "class" "module" "do" "{" "[")) ; Block start
                     ,(rx (or "}" "]" "end"))                       ; Block end
                     ,(rx bol
                          (or (+ (zero-or-more blank) "#") "=begin")) ; Comment start
                     ruby-forward-sexp nil)
                   hs-special-modes-alist
                   :test #'equal)))
   #+END_SRC

*** Testing
    #+BEGIN_SRC emacs-lisp
    (defun ruby-test-all ()
      "Test all files using either RSpec or MiniTest."
      (interactive)
      (if (bound-and-true-p rspec-mode)
          (rspec-verify-all)
        (minitest-verify-all)))

    (defun ruby-test-file ()
      "Test current file using either RSpec or MiniTest."
      (interactive)
      (if (bound-and-true-p rspec-mode)
          (rspec-verify)
        (minitest-verify)))

    (defun ruby-test-at-point ()
      "Test definition at point using either RSpec or MiniTest."
      (interactive)
      (if (bound-and-true-p rspec-mode)
          (rspec-verify-single)
        (minitest-verify-single)))

    (general-define-key
     :keymaps 'ruby-mode-map
     :prefix +local-leader-key
     "t" 'ruby-test-at-point
     "T" 'ruby-test-file
     "s" 'ruby-test-all)
    #+END_SRC

*** Packages
**** inf-ruby
     #+BEGIN_SRC emacs-lisp
     (use-package inf-ruby
       :hook
       (ruby-mode . inf-ruby-minor-mode)
       ;; Auto breakpoint
       (compilation-filter . inf-ruby-auto-enter)
       :custom
       (inf-ruby-default-implementation "pry")
       :general
       (:keymaps
        'ruby-mode-map
        :prefix +local-leader-key
        "r" 'inf-ruby))
     #+END_SRC

**** minitest
     #+BEGIN_SRC emacs-lisp
     (use-package minitest
       :hook
       (ruby-mode . minitest-enable-appropriate-mode))
     #+END_SRC

**** rake
     #+BEGIN_SRC emacs-lisp
     (use-package rake
       :custom
       (rake-completion-system 'default)
       (rake-cache-file (expand-file-name "rake.cache" +cache-dir)))
     #+END_SRC

**** rspec-mode
     #+BEGIN_SRC emacs-lisp
     (use-package rspec-mode
       :hook
       (ruby-mode . rspec-enable-appropriate-mode)
       :custom
       (rspec-use-relative-path t)
       (rspec-use-opts-file-when-available nil)
       (rspec-command-options "--format progress"))
     #+END_SRC

**** rubocopfmt
     #+BEGIN_SRC emacs-lisp
     (use-package rubocopfmt
       :diminish rubocopfmt-mode
       :hook
       (ruby-mode . rubocopfmt-mode)
       :custom
       (rubocopfmt-use-bundler-when-possible nil)
       :general
       (:keymaps
        'ruby-mode-map
        :prefix +local-leader-key
        "f" 'rubocopfmt-mode))
     #+END_SRC

**** ruby-refactor
     #+BEGIN_SRC emacs-lisp
     (use-package ruby-refactor
       :diminish ruby-refactor-mode
       :hook
       (ruby-mode . ruby-refactor-mode)
       :general
       (:keymaps
        'ruby-mode-map
        :prefix +local-leader-key
        "R" '(:ignore t :wk "refactor...")
        "Rb" 'ruby-toggle-block
        "Rc" 'ruby-refactor-convert-post-conditional
        "Re" '(:ignore t :wk "extract...")
        "Rec" '(ruby-refactor-extract-constant       :wk "constant")
        "Rel" '(ruby-refactor-extract-to-let         :wk "to let")
        "Rem" '(ruby-refactor-extract-to-method      :wk "to method")
        "Rev" '(ruby-refactor-extract-local-variable :wk "variable")
        "Rp" 'ruby-refactor-add-parameter))
     #+END_SRC

**** yard-mode
     #+BEGIN_SRC emacs-lisp
     (use-package yard-mode
       :diminish yard-mode
       :hook ruby-mode)
     #+END_SRC

**** yari
     #+BEGIN_SRC emacs-lisp
     (use-package yari
       :general
       (:keymaps
        'ruby-mode-map
        "M-g k" 'yari)
       (:keymaps
        'help-command-map
        "R" 'yari))
     #+END_SRC

** rust
   #+BEGIN_SRC emacs-lisp
   (use-package rustic
     :custom
     (rustic-rls-pkg 'eglot)
     :general
     (:keymaps
      'rustic-mode-map
      :prefix +local-leader-key
      "t" 'rustic-cargo-test)
     :init
     (with-eval-after-load 'org
       (cl-pushnew '("rust" . rustic) org-src-lang-modes :test #'equal))
     :config
     (require 'eglot))
   #+END_SRC

** salt
   #+BEGIN_SRC emacs-lisp
   (use-package salt-mode
     :general
     (:keymaps
      'salt-mode-map
      "M-g k" 'salt-mode-browse-doc))
   #+END_SRC

** scala
   #+BEGIN_SRC emacs-lisp
   (use-package scala-mode
     :hook
     (scala-mode . +scala-prettify-symbols-setup)
     :custom
     (scala-indent:align-parameters t)
     :preface
     (defun +scala-prettify-symbols-setup ()
       (setq prettify-symbols-alist scala-prettify-symbols-alist)))
   #+END_SRC

*** Packages
**** sbt-mode
     #+BEGIN_SRC emacs-lisp
     (use-package sbt-mode)
     #+END_SRC

** sh
   #+BEGIN_SRC emacs-lisp
   (use-package sh-script
     :custom
     ;; Use regular indentation for line-continuation
     (sh-indent-after-continuation 'always)
     :general
     (:keymaps
      'sh-mode-map
      "M-g k" 'man))
   #+END_SRC

*** Packages
**** flymake-shellcheck
     #+BEGIN_SRC emacs-lisp
     (use-package flymake-shellcheck
       :hook
       (sh-mode . flymake-mode)
       (sh-mode . flymake-shellcheck-load))
     #+END_SRC

** sql
   #+BEGIN_SRC emacs-lisp
   (use-package sql
     :custom
     (sql-mysql-options '("--protocol=tcp" "--prompt=" "--disable-pager")))
   #+END_SRC

** term
    #+BEGIN_SRC emacs-lisp
    (use-package term
      :hook
      (term . turn-off-truncate-lines)
      :custom
      (explicit-shell-file-name "fish")
      :general
      (:prefix
       +launch-prefix
       "T" 'term))
    #+END_SRC

** typescript
   #+BEGIN_SRC emacs-lisp
   (use-package typescript-mode
     :hook
     (typescript-mode . +typescript-find-file-setup)
     (typescript-mode . +typescript-prettify-symbols-setup)
     :preface
     (defun +typescript-find-file-setup ()
       "Setup `ff-test-find-other-file' support for `typescript-mode'."
       (setq ff-test-search-implementation-project-directories '("src")
             ff-test-search-test-directories '("." "__tests__")
             ff-test-search-test-project-directories '("test" "spec" "__tests__")))

     (defun +typescript-prettify-symbols-setup ()
       (dolist (symbol '(("=="        . ?≈)
                         ("!="        . "≈/")
                         ("=>"        . (?- (Br . Bc) ?- (Br . Bc) ?>))
                         ("function"  . ?ƒ)
                         ("let"       . ?ν)
                         ("const"     . "ν_")
                         ("null"      . ?∅)
                         ("Infinity"  . ?∞)))
         (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
   #+END_SRC

*** Packages
**** ts-comint
     TypeScript REPL.
     #+BEGIN_SRC emacs-lisp
     (use-package ts-comint
       :custom
       (ts-comint-program-command "ts-node"))
     #+END_SRC

**** jest
     Test framework execution.
     #+BEGIN_SRC emacs-lisp
     (use-package jest
       :general
       (:keymaps
        'typescript-mode-map
        :prefix +local-leader-key
        "t" 'jest-function-dwim
        "T" 'jest-file
        "s" 'jest-popup))
     #+END_SRC

** web
*** Packages
**** cakecrumbs
     Display current path for HTML/XML/CSS.
     #+BEGIN_SRC emacs-lisp
     (use-package cakecrumbs
       :config
       (cakecrumbs-auto-setup))
     #+END_SRC

**** emmet-mode
     Snippets and Zen Coding for HTML.
     #+BEGIN_SRC emacs-lisp
     (use-package emmet-mode
       :hook
       (css-mode
        haml-mode
        html-mode
        nxml-mode
        rjsx-mode
        web-mode)
       (rjsx-mode . +emmet-use-jsx-className)
       :custom
       (emmet-move-cursor-between-quotes t)
       :preface
       (defun +emmet-use-jsx-className ()
         "Set `emmet-expand-jsx-className?' as local variable."
         (setq-local emmet-expand-jsx-className? t)))
     #+END_SRC

**** pug-mode
     #+BEGIN_SRC emacs-lisp
     (use-package pug-mode)
     #+END_SRC

**** slim-mode
     #+BEGIN_SRC emacs-lisp
     (use-package slim-mode)
     #+END_SRC

**** web-mode
     #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :mode
       "\\.\\(phtml\\|php\\|[agj]sp\\|as[cp]x\\|erb\\|djhtml\\|html?\\|hbs\\|ejs\\|jade\\|swig\\|tmpl\\)$"
       :custom
       (web-mode-enable-html-entities-fontification t)
       ;; Highlight enclosing tags of the element under cursor
       (web-mode-enable-current-element-highlight t)
       ;; No extra indentation for blocks.
       (web-mode-script-padding 0)
       (web-mode-style-padding 0))
     #+END_SRC

** yaml
   #+BEGIN_SRC emacs-lisp
   (use-package yaml-mode
     :hook (yaml-mode . indent-guide-mode))
   #+END_SRC

* Tools
** E-mail
*** Packages
**** bbdb
     Store contacts.
     #+BEGIN_SRC emacs-lisp
     (use-package bbdb)
     #+END_SRC

**** gmail2bbdb
     Import contacts from Gmail vCard data.
     #+BEGIN_SRC emacs-lisp
     (use-package gmail2bbdb
       :config
       (setq gmail2bbdb-bbdb-file bbdb-file
             gmail2bbdb-exclude-people-without-name t))
     #+END_SRC

** Focus
   Dim out the surrounding text except the current focused paragraph or expression.
   #+BEGIN_SRC emacs-lisp
   (use-package focus
     :diminish focus-mode)
   #+END_SRC

** Indentation guides
   #+BEGIN_SRC emacs-lisp
   (use-package indent-guide
     :diminish indent-guide-mode
     :custom
     (indent-guide-char "\x2502"))
   #+END_SRC

** Pomodoro
   #+BEGIN_SRC emacs-lisp
   (use-package redtick
     :general
     (:prefix
      +launch-prefix
      "r" 'redtick))
   #+END_SRC

** Recording
   #+BEGIN_SRC emacs-lisp
   (use-package camcorder
     :custom
     (output-directory (getenv "XDG_VIDEOS_DIR"))
     (gif-output-directory (getenv "XDG_VIDEOS_DIR"))
     :general
     (:prefix
      +launch-prefix
      "c" 'camcorder-record))
   #+END_SRC

** Session
   Support for restoring previous session on Emacs restart. This adds a few tweaks that
   makes it really useful.
   - Support for persistent undo history via =buffer-indo-list=.
   - Ignore saving of =gz= files as it seems not to properly load those.
   - Only restore 5 files to begin with to avoid slow starts with huge sessions.
   #+BEGIN_SRC emacs-lisp
   (use-package desktop
     :demand t
     :custom
     (desktop-files-not-to-save "\\(\\`/[^/:]*:\\|(ftp)\\|\\.gz\\'\\)")
     (desktop-restore-eager 0)
     (desktop-save (daemonp))
     (desktop-load-locked-desktop (daemonp))
     :preface
     (defun +append-buffer-undo-list-to-buffer-local-variables-advice (orig-fn &rest args)
       "Override `buffer-local-variables' and call ORIG-FN with ARGS.
     There is a bug in Emacs where the `buffer-undo-list' data is
     missing from the output of `buffer-local-variables'. This
     advice temporarily overrides the function and appends the
     missing data."
       (let ((orig-buffer-local-variables-fn (symbol-function 'buffer-local-variables)))
         (cl-letf (((symbol-function 'buffer-local-variables)
                    #'(lambda () (append (funcall orig-buffer-local-variables-fn)
                                         `(,(cons 'buffer-undo-list buffer-undo-list))))))
           (apply orig-fn args))))
     :config
     (advice-add #'desktop-buffer-info :around #'+append-buffer-undo-list-to-buffer-local-variables-advice)

     (cl-pushnew 'buffer-undo-list desktop-locals-to-save :test #'equal)
     (cl-pushnew 'ivy-views desktop-globals-to-save :test #'equal)

     (desktop-save-mode 1))
   #+END_SRC

** Spell checking
   #+BEGIN_SRC emacs-lisp
   (use-package flyspell
     :diminish flyspell-mode
     :hook
     ((text-mode
       message-mode) . flyspell-mode)
     (prog-mode . flyspell-prog-mode)
     :general
     (:keymaps
      'flyspell-mode-map
      "C-," 'nil
      "C-." 'nil))
   #+END_SRC

   Automatically infer dictionary.
   #+BEGIN_SRC emacs-lisp
   (use-package auto-dictionary)
   #+END_SRC

** Undo
   Navigate through undo history.
   #+BEGIN_SRC emacs-lisp
   (use-package undo-propose
     :general
     (:prefix
      +launch-prefix
      "u" 'undo-propose))
   #+END_SRC

* The end
  #+BEGIN_SRC emacs-lisp
  (provide 'init)
  ;;; init.el ends here
  #+END_SRC

* Tasks
** TODO Look into skewer packages
** TODO Look into modal editing with =objed=
** TODO Look into generic code execution via =isend-mode=
** TODO Add binding for org-noter
** TODO Group editing bindings under some logical prefix
** TODO Improve window keys
** TODO Improve find char keys
** TODO Override =M-o= with something useful?
** TODO Override =M-n= with something useful?
** TODO Override =M-p= with something useful?
** TODO Easier way to toggle =subword-mode=
** TODO Easier way to toggle =glasses-mode=
** TODO Extract history persistance code (persistory)
   - comint
   - ielm (via comint and savehist)
   - haskell-interactive (via savehist)
** TODO Enable auto-revert/save again?
** TODO Wrap lines by default?
     When writing code on a single line, to later let it be expanded by the formatter.
